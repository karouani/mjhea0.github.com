<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Node | Michael Herman]]></title>
  <link href="http://mherman.org/blog/categories/node/atom.xml" rel="self"/>
  <link href="http://mherman.org/"/>
  <updated>2017-09-18T07:41:46-06:00</updated>
  <id>http://mherman.org/</id>
  <author>
    <name><![CDATA[Michael Herman]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Building a RESTful API With Koa and Postgres]]></title>
    <link href="http://mherman.org/blog/2017/08/23/building-a-restful-api-with-koa-and-postgres/"/>
    <updated>2017-08-23T08:31:03-06:00</updated>
    <id>http://mherman.org/blog/2017/08/23/building-a-restful-api-with-koa-and-postgres</id>
    <content type="html"><![CDATA[<p>In this tutorial, you&rsquo;ll learn how to develop a RESTful API with <a href="http://koajs.com/">Koa</a> 2 and Postgres. You&rsquo;ll also be taking advantage of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async/await</a> functions, from ES2017, and test driven development (TDD).</p>

<blockquote><p>This tutorial requires Node v<a href="https://nodejs.org/en/blog/release/v7.6.0/">7.6.0</a> or greater.</p></blockquote>

<div style="text-align:center;">
  <img src="http://mherman.org/images/blog/node-koa-api.png" style="max-width: 90%; border:0; box-shadow: none;" alt="architecture">
</div>


<p><br></p>

<h4>NPM Dependencies</h4>

<ol>
<li>Koa v<a href="https://github.com/koajs/koa/releases/tag/2.3.0">2.3.0</a></li>
<li>Mocha v<a href="https://github.com/mochajs/mocha/releases/tag/v3.5.0">3.5.0</a></li>
<li>Chai v<a href="https://github.com/chaijs/chai/releases/tag/4.1.1">4.1.1</a></li>
<li>Chai HTTP v<a href="https://github.com/chaijs/chai-http/releases/tag/3.0.0">3.0.0</a></li>
<li>Knex v<a href="https://github.com/tgriesser/knex/releases/tag/0.13.0">0.13.0</a></li>
<li>pg v<a href="https://github.com/brianc/node-postgres/releases/tag/v7.1.2">7.1.2</a></li>
<li>koa-router v<a href="https://github.com/alexmingoia/koa-router/releases/tag/v7.2.1">7.2.1</a></li>
<li>koa-bodyparser v<a href="https://github.com/koajs/bodyparser/releases/tag/4.2.0">4.2.0</a></li>
</ol>


<h2>Contents</h2>

<ol>
<li>Objectives</li>
<li>Getting Started</li>
<li>Project Setup</li>
<li>Routes</li>
<li>Next Steps</li>
</ol>


<h2>Objectives</h2>

<p>By the end of this tutorial, you will be able to&hellip;</p>

<ol>
<li>Set up a project with Koa using test driven development</li>
<li>Write schema migration files with Knex to create new database tables</li>
<li>Generate database seed files with Knex and apply the seeds to the database</li>
<li>Set up the testing structure with Mocha and Chai</li>
<li>Perform the basic CRUD functions on a RESTful resource with Knex methods</li>
<li>Create a CRUD app, following RESTful best practices</li>
<li>Write integration tests</li>
<li>Write tests, and then write just enough code to pass the tests</li>
<li>Create routes with Koa Router</li>
<li>Parse the request body with koa-bodyparser</li>
</ol>


<h2>Getting Started</h2>

<h3>What are we building?</h3>

<p>Your goal is to design a RESTful API, using test driven development, for a single resource - <code>movies</code>. The API itself should follow RESTful design principles, using the <a href="http://www.restapitutorial.com/lessons/httpmethods.html">basic HTTP verbs</a>: GET, POST, PUT, and DELETE.</p>

<h3>What is Koa?</h3>

<p>Koa is a web framework for Node.js.</p>

<p>Although it&rsquo;s designed by the same team that created Express, it&rsquo;s much lighter than Express though - so it comes with very little out of the box. It&rsquo;s really just a tiny wrapper on top of Node&rsquo;s <a href="https://nodejs.org/api/http.html#http_http">HTTP</a> module. Koa allows you - the developer - to pick and choose the tools you want to use from the <a href="https://github.com/koajs/koa/wiki">community</a>.</p>

<p>It has native support for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">async/await</a>, which makes it easier and faster to develop an API since you don&rsquo;t have to deal with <a href="https://en.wikipedia.org/wiki/Callback_(computer_programming%29">callbacks</a> and <a href="http://callbackhell.com/">callback hell</a>.</p>

<p>Finally, since Koa has similar patterns to Express, it&rsquo;s relatively easy to pick up if you&rsquo;ve worked at all with Express.</p>

<blockquote><p><strong>NOTE</strong>: For more, review <a href="https://github.com/koajs/koa/blob/master/docs/koa-vs-express.md">Koa vs Express</a>.</p></blockquote>

<h3>TDD</h3>

<p>Test Driven Development (TDD) is an iterative development cycle that emphasizes writing automated tests <em>before</em> writing the actual code.</p>

<h4>Why?</h4>

<ol>
<li>Helps break down problems into manageable pieces since you should have a better understanding of what you&rsquo;re going to write</li>
<li>Forces you to write cleaner code</li>
<li>Prevents over coding</li>
</ol>


<h4>Red-Green-Refactor</h4>

<p>TDD often follows the &ldquo;Red-Green-Refactor&rdquo; development cycle:</p>

<ol>
<li><span style="color:red">RED</span>: Write a test, which should fail when you run it</li>
<li><span style="color:green">GREEN</span>: Write just enough code for the test to pass</li>
<li><span style="color:orange">REFACTOR</span>: Refactor code and retest, again and again (if necessary)</li>
</ol>


<h2>Project Setup</h2>

<p>Start by cloning down the base project:</p>

<pre><code class="sh">$ git clone https://github.com/mjhea0/node-koa-api \
  --branch v1 --single-branch
$ cd node-koa-api
</code></pre>

<p>Then, check out the <a href="https://github.com/mjhea0/node-koa-api/releases/tag/v1">v1</a> tag to the master branch and install the dependencies:</p>

<pre><code class="sh">$ git checkout tags/v1 -b master
$ npm install
</code></pre>

<p>Run two quick sanity checks to make sure all is well:</p>

<pre><code class="sh">$ npm start
It works!

$ npm test
Sample Test
  âœ“ should pass

1 passing (8ms)
</code></pre>

<p>Take a quick look at the project structure before moving on.</p>

<h3>Koa</h3>

<p>As always, we&rsquo;ll begin with the obligatory hello world. But first, since we&rsquo;re following TDD, let&rsquo;s write a quick test.</p>

<p>Install <a href="https://github.com/chaijs/chai-http">Chai HTTP</a> so we can test HTTP calls:</p>

<pre><code class="sh">$ npm install chai-http@3.0.0 --save-dev
</code></pre>

<p>Create a new file in the &ldquo;test&rdquo; directory called <em>routes.index.test.js</em>:</p>

<pre><code class="javascript">process.env.NODE_ENV = 'test';

const chai = require('chai');
const should = chai.should();
const chaiHttp = require('chai-http');
chai.use(chaiHttp);

const server = require('../src/server/index');

describe('routes : index', () =&gt; {

  describe('GET /', () =&gt; {
    it('should return json', (done) =&gt; {
      chai.request(server)
      .get('/')
      .end((err, res) =&gt; {
        should.not.exist(err);
        res.status.should.eql(200);
        res.type.should.eql('application/json');
        res.body.status.should.equal('success');
        res.body.message.should.eql('hello, world!');
        done();
      });
    });
  });

});
</code></pre>

<p>So, within the second <code>describe</code> block, we have a single <code>it</code> statement, which defines a test case. In this simple case, we&rsquo;re testing the response from a GET request to the main route, <code>/</code>.</p>

<p>Run the test via <code>npm test</code>. You should see the following error since the server is not setup:</p>

<pre><code class="sh">TypeError: app.address is not a function
</code></pre>

<p>Next, let&rsquo;s stand up a quick Koa server. Install Koa:</p>

<pre><code class="sh">$ npm install koa@2.3.0 --save
</code></pre>

<p>Then, update <em>src/server/index.js</em> like so:</p>

<pre><code class="javascript">const Koa = require('koa');

const app = new Koa();
const PORT = 1337;

app.use(async (ctx) =&gt; {
  ctx.body = {
    status: 'success',
    message: 'hello, world!'
  };
});

const server = app.listen(PORT, () =&gt; {
  console.log(`Server listening on port: ${PORT}`);
});

module.exports = server;
</code></pre>

<p>Here, we created a new instance of Koa and then mounted a basic async function to the app. This function takes the Koa <a href="http://koajs.com/#context">context</a> as a parameter, <code>ctx</code>. It&rsquo;s worth noting that this object encapsulates both the Node request and response objects. We then set the return value to <code>ctx.body</code>, which will be sent back as the response body when user hits any route.</p>

<p>Run the Koa server, via <code>npm start</code>, and then navigate to <a href="http://localhost:1337/">http://localhost:1337/</a>. You should see:</p>

<pre><code class="json">{
  "status": "success",
  "message": "hello, world!"
}
</code></pre>

<p>Once done, kill the server and then run the tests. They should now pass.</p>

<h3>Database</h3>

<p>Moving right along, <a href="https://www.postgresql.org/download/">download</a> and install Postgres, if you don&rsquo;t already have it, and then fire up the server on port 5432.</p>

<p>Along with Postgres, we&rsquo;ll use <a href="https://node-postgres.com/">pg</a> and <a href="http://knexjs.org/">Knex</a> to interact with the database itself:</p>

<pre><code class="sh">$ npm install pg@7.1.2 knex@0.13.0 --save
</code></pre>

<p>Install Knex globally as well so you can use the CLI tool:</p>

<pre><code class="sh">$ npm install knex@0.13.0 -g
</code></pre>

<p>Next, we need to create two new databases, one for our development environment and the other for test environment.</p>

<p>Open psql in the terminal, and create the databases:</p>

<pre><code class="sh">$ psql
psql (9.6.1)

# CREATE DATABASE koa_api;
CREATE DATABASE
# CREATE DATABASE koa_api_test;
CREATE DATABASE
# \q
</code></pre>

<p>With that, we can now initialize Knex.</p>

<h3>Knex</h3>

<p>Run <code>knex init</code> in the project root to initialize a new <a href="http://knexjs.org/#knexfile">config file</a> called <em>knexfile.js</em>. Override the default info with:</p>

<pre><code class="javascript">const path = require('path');

const BASE_PATH = path.join(__dirname, 'src', 'server', 'db');

module.exports = {
  test: {
    client: 'pg',
    connection: 'postgres://username:password@localhost:5432/koa_api_test',
    migrations: {
      directory: path.join(BASE_PATH, 'migrations')
    },
    seeds: {
      directory: path.join(BASE_PATH, 'seeds')
    }
  },
  development: {
    client: 'pg',
    connection: 'postgres://username:password@localhost:5432/koa_api',
    migrations: {
      directory: path.join(BASE_PATH, 'migrations')
    },
    seeds: {
      directory: path.join(BASE_PATH, 'seeds')
    }
  }
};
</code></pre>

<blockquote><p><strong>NOTE:</strong> Make sure to replace <code>username</code> and <code>password</code> with your database username and password, respectively.</p></blockquote>

<p>Next, let&rsquo;s create a new migration to define the database schema:</p>

<pre><code class="sh">$ knex migrate:make movies
</code></pre>

<p>This created a &ldquo;src/server/db/migrations&rdquo; folder with a timestamped migration file. Update the file like so:</p>

<pre><code class="javascript">exports.up = (knex, Promise) =&gt; {
  return knex.schema.createTable('movies', (table) =&gt; {
    table.increments();
    table.string('name').notNullable().unique();
    table.string('genre').notNullable();
    table.integer('rating').notNullable();
    table.boolean('explicit').notNullable();
  });
};

exports.down = (knex, Promise) =&gt; {
  return knex.schema.dropTable('movies');
};
</code></pre>

<p>Add a new file to the &ldquo;db&rdquo; folder called <em>connection.js</em> to, well, connect to the database using the appropriate Knex configuration based on the environment (development, test, staging, production, etc.):</p>

<pre><code class="javascript">const environment = process.env.NODE_ENV || 'development';
const config = require('../../../knexfile.js')[environment];

module.exports = require('knex')(config);
</code></pre>

<p>Apply the migration to the development database:</p>

<pre><code class="sh">$ knex migrate:latest --env development
</code></pre>

<p>Next, let&rsquo;s create a seed file to populate the database with some initial data:</p>

<pre><code class="sh">$ knex seed:make movies_seed
</code></pre>

<p>This added a seed file to &ldquo;src/server/db/seeds&rdquo;; update it to match the database schema:</p>

<pre><code class="javascript">exports.seed = (knex, Promise) =&gt; {
  return knex('movies').del()
  .then(() =&gt; {
    return knex('movies').insert({
      name: 'The Land Before Time',
      genre: 'Fantasy',
      rating: 7,
      explicit: false
    });
  })
  .then(() =&gt; {
    return knex('movies').insert({
      name: 'Jurassic Park',
      genre: 'Science Fiction',
      rating: 9,
      explicit: true
    });
  })
  .then(() =&gt; {
    return knex('movies').insert({
      name: 'Ice Age: Dawn of the Dinosaurs',
      genre: 'Action/Romance',
      rating: 5,
      explicit: false
    });
  });
};
</code></pre>

<p>Apply the seed:</p>

<pre><code class="sh">$ knex seed:run --env development
</code></pre>

<p>Finally, hop back into psql to ensure the database has been updated:</p>

<pre><code class="sh">$ psql
psql (9.6.1)

# \c koa_api
You are now connected to database "koa_api".
# select * from movies;
 id |              name              |      genre      | rating | explicit
----+--------------------------------+-----------------+--------+----------
  1 | The Land Before Time           | Fantasy         |      7 | f
  2 | Jurassic Park                  | Science Fiction |      9 | t
  3 | Ice Age: Dawn of the Dinosaurs | Action/Romance  |      5 | f
(3 rows)

# \q
</code></pre>

<h3>Koa Router</h3>

<p>Unlike Express, Koa does not provide any routing middleware. There are a number of options available, but we&rsquo;ll use <a href="https://github.com/alexmingoia/koa-router">koa-router</a> due to its simplicity.</p>

<pre><code class="sh">$ npm install koa-router@7.2.1 --save
</code></pre>

<p>Create a new folder called &ldquo;routes&rdquo; within &ldquo;server&rdquo;, and then add an <em>index.js</em> file to it:</p>

<pre><code class="javascript">const Router = require('koa-router');
const router = new Router();

router.get('/', async (ctx) =&gt; {
  ctx.body = {
    status: 'success',
    message: 'hello, world!'
  };
})

module.exports = router;
</code></pre>

<p>Then, update <em>src/server/index.js</em>:</p>

<pre><code class="javascript">const Koa = require('koa');
const indexRoutes = require('./routes/index');

const app = new Koa();
const PORT = process.env.PORT || 1337;

app.use(indexRoutes.routes());

const server = app.listen(PORT, () =&gt; {
  console.log(`Server listening on port: ${PORT}`);
});

module.exports = server;
</code></pre>

<p>Essentially, we moved the <code>/</code> route out of the main application file. Ensure the tests still pass before moving on.</p>

<h2>Routes</h2>

<p>Again, we&rsquo;ll take a test-first approach to writing our routes:</p>

<table>
<thead>
<tr>
<th> URL                 </th>
<th> HTTP Verb </th>
<th> Action                </th>
</tr>
</thead>
<tbody>
<tr>
<td> /api/v1/movies      </td>
<td> GET       </td>
<td> Return ALL movies     </td>
</tr>
<tr>
<td> /api/v1/movies/:id  </td>
<td> GET       </td>
<td> Return a SINGLE movie </td>
</tr>
<tr>
<td> /api/v1/movies      </td>
<td> POST      </td>
<td> Add a movie           </td>
</tr>
<tr>
<td> /api/v1/movies/:id  </td>
<td> PUT       </td>
<td> Update a movie        </td>
</tr>
<tr>
<td> /api/v1/movies/:id  </td>
<td> DELETE    </td>
<td> Delete a movie        </td>
</tr>
</tbody>
</table>


<p>Before diving in, let&rsquo;s add some structure. First, add a new folder called &ldquo;queries&rdquo; to the &ldquo;db&rdquo; folder, and then add a file called <em>movies.js</em> to that newly created folder:</p>

<pre><code class="javascript">const knex = require('../connection');
</code></pre>

<p>We&rsquo;ll add the database queries associated with the <code>movies</code> resource to this file. Next, add a new route file called <em>movies.js</em> to &ldquo;routes&rdquo;:</p>

<pre><code class="javascript">const Router = require('koa-router');
const queries = require('../db/queries/movies');

const router = new Router();
const BASE_URL = `/api/v1/movies`;

module.exports = router;
</code></pre>

<p>Then, wire this file up to the main application in <em>src/server/index.js</em>:</p>

<pre><code class="javascript">const Koa = require('koa');
const indexRoutes = require('./routes/index');
const movieRoutes = require('./routes/movies');

const app = new Koa();
const PORT = process.env.PORT || 1337;

app.use(indexRoutes.routes());
app.use(movieRoutes.routes());

const server = app.listen(PORT, () =&gt; {
  console.log(`Server listening on port: ${PORT}`);
});

module.exports = server;
</code></pre>

<p>Finally, add a new test file to &ldquo;test&rdquo; called <em>routes.movies.test.js</em>:</p>

<pre><code class="javascript">process.env.NODE_ENV = 'test';

const chai = require('chai');
const should = chai.should();
const chaiHttp = require('chai-http');
chai.use(chaiHttp);

const server = require('../src/server/index');
const knex = require('../../src/server/db/connection');

describe('routes : movies', () =&gt; {

  beforeEach(() =&gt; {
    return knex.migrate.rollback()
    .then(() =&gt; { return knex.migrate.latest(); })
    .then(() =&gt; { return knex.seed.run(); });
  });

  afterEach(() =&gt; {
    return knex.migrate.rollback();
  });


});
</code></pre>

<p>So, when the tests are ran, the <code>beforeEach()</code> is fired before any of test specs, applying the migrations to the test database. After the specs run, the database is rolled back to a pristine state in the <code>afterEach()</code>.</p>

<p>With that, let&rsquo;s add our routes!</p>

<h3>GET All Movies</h3>

<p>Start with a test:</p>

<pre><code class="javascript">describe('GET /api/v1/movies', () =&gt; {
  it('should return all movies', (done) =&gt; {
    chai.request(server)
    .get('/api/v1/movies')
    .end((err, res) =&gt; {
      // there should be no errors
      should.not.exist(err);
      // there should be a 200 status code
      res.status.should.equal(200);
      // the response should be JSON
      res.type.should.equal('application/json');
      // the JSON response body should have a
      // key-value pair of {"status": "success"}
      res.body.status.should.eql('success');
      // the JSON response body should have a
      // key-value pair of {"data": [3 movie objects]}
      res.body.data.length.should.eql(3);
      // the first object in the data array should
      // have the right keys
      res.body.data[0].should.include.keys(
        'id', 'name', 'genre', 'rating', 'explicit'
      );
      done();
    });
  });
});
</code></pre>

<p>Take note of the code comments. Review <a href="http://mherman.org/blog/2015/09/10/testing-node-js-with-mocha-and-chai/">Testing Node.js With Mocha and Chai</a> for more info. Run the test to make sure it fails:</p>

<pre><code class="sh">Uncaught AssertionError: expected [Error: Not Found] to not exist
</code></pre>

<p>To get the test to pass, add the route handler to <em>src/server/routes/movies.js</em>:</p>

<pre><code class="javascript">router.get(BASE_URL, async (ctx) =&gt; {
  try {
    const movies = await queries.getAllMovies();
    ctx.body = {
      status: 'success',
      data: movies
    };
  } catch (err) {
    console.log(err)
  }
})
</code></pre>

<p>Add the DB query to <em>src/server/db/queries/movies.js</em>:</p>

<pre><code class="javascript">const knex = require('../connection');

function getAllMovies() {
  return knex('movies')
  .select('*');
}

module.exports = {
  getAllMovies
};
</code></pre>

<p>So, <code>getAllMovies()</code> returns a promise object. Then, within the <code>async</code> function, execution stops at the <code>await</code>. Execution continues once the promise is resolved.</p>

<p>Run the tests to ensure they pass:</p>

<pre><code class="sh">routes : index
  GET /
    âœ“ should return json

routes : movies
  GET /api/v1/movies
    âœ“ should return all movies

Sample Test
  âœ“ should pass


3 passing (177ms)
</code></pre>

<h3>GET Single Movie</h3>

<p>What if we just want a single movie?</p>

<pre><code class="javascript">describe('GET /api/v1/movies/:id', () =&gt; {
  it('should respond with a single movie', (done) =&gt; {
    chai.request(server)
    .get('/api/v1/movies/1')
    .end((err, res) =&gt; {
      // there should be no errors
      should.not.exist(err);
      // there should be a 200 status code
      res.status.should.equal(200);
      // the response should be JSON
      res.type.should.equal('application/json');
      // the JSON response body should have a
      // key-value pair of {"status": "success"}
      res.body.status.should.eql('success');
      // the JSON response body should have a
      // key-value pair of {"data": 1 movie object}
      res.body.data[0].should.include.keys(
        'id', 'name', 'genre', 'rating', 'explicit'
      );
      done();
    });
  });
});
</code></pre>

<p>Make sure the test fails, and then add the route handler:</p>

<pre><code class="javascript">router.get(`${BASE_URL}/:id`, async (ctx) =&gt; {
  try {
    const movie = await queries.getSingleMovie(ctx.params.id);
    ctx.body = {
      status: 'success',
      data: movie
    };
  } catch (err) {
    console.log(err)
  }
})
</code></pre>

<p>Add the query as well:</p>

<pre><code class="javascript">function getSingleMovie(id) {
  return knex('movies')
  .select('*')
  .where({ id: parseInt(id) });
}
</code></pre>

<p>Don&rsquo;t forget to export it:</p>

<pre><code class="javascript">module.exports = {
  getAllMovies,
  getSingleMovie,
};
</code></pre>

<p>The test should now pass. Before moving on though, what happens if the movie ID does not exist? Start with a test to find out.</p>

<p>Add an <code>it</code> block to the previous <code>describe</code> block:</p>

<pre><code class="javascript">it('should throw an error if the movie does not exist', (done) =&gt; {
  chai.request(server)
  .get('/api/v1/movies/9999999')
  .end((err, res) =&gt; {
    // there should an error
    should.exist(err);
    // there should be a 404 status code
    res.status.should.equal(404);
    // the response should be JSON
    res.type.should.equal('application/json');
    // the JSON response body should have a
    // key-value pair of {"status": "error"}
    res.body.status.should.eql('error');
    // the JSON response body should have a
    // key-value pair of {"message": "That movie does not exist."}
    res.body.message.should.eql('That movie does not exist.');
    done();
  });
});
</code></pre>

<p>Make sure the test fails before updating the code:</p>

<pre><code class="javascript">router.get(`${BASE_URL}/:id`, async (ctx) =&gt; {
  try {
    const movie = await queries.getSingleMovie(ctx.params.id);
    if (movie.length) {
      ctx.body = {
        status: 'success',
        data: movie
      };
    } else {
      ctx.status = 404;
      ctx.body = {
        status: 'error',
        message: 'That movie does not exist.'
      };
    }
  } catch (err) {
    console.log(err)
  }
})
</code></pre>

<p>The test should now pass.</p>

<h3>POST</h3>

<p>How about adding a new movie to the database?</p>

<pre><code class="javascript">describe('POST /api/v1/movies', () =&gt; {
  it('should return the movie that was added', (done) =&gt; {
    chai.request(server)
    .post('/api/v1/movies')
    .send({
      name: 'Titanic',
      genre: 'Drama',
      rating: 8,
      explicit: true
    })
    .end((err, res) =&gt; {
      // there should be no errors
      should.not.exist(err);
      // there should be a 201 status code
      // (indicating that something was "created")
      res.status.should.equal(201);
      // the response should be JSON
      res.type.should.equal('application/json');
      // the JSON response body should have a
      // key-value pair of {"status": "success"}
      res.body.status.should.eql('success');
      // the JSON response body should have a
      // key-value pair of {"data": 1 movie object}
      res.body.data[0].should.include.keys(
        'id', 'name', 'genre', 'rating', 'explicit'
      );
      done();
    });
  });
});
</code></pre>

<p>Koa does not parse the request body by default, so we need to add middleware for body parsing. <a href="https://github.com/koajs/bodyparser">koa-bodyparser</a> is a popular choice:</p>

<pre><code class="sh">$ npm install koa-bodyparser@4.2.0 --save
</code></pre>

<p>Add the requirement to <em>src/server/index.js</em>, and then make sure to mount the middleware to the app before the routes:</p>

<pre><code class="javascript">const Koa = require('koa');
const bodyParser = require('koa-bodyparser');

const indexRoutes = require('./routes/index');
const movieRoutes = require('./routes/movies');

const app = new Koa();
const PORT = process.env.PORT || 1337;

app.use(bodyParser());
app.use(indexRoutes.routes());
app.use(movieRoutes.routes());

const server = app.listen(PORT, () =&gt; {
  console.log(`Server listening on port: ${PORT}`);
});

module.exports = server;
</code></pre>

<p>Add the route handler:</p>

<pre><code class="javascript">router.post(`${BASE_URL}`, async (ctx) =&gt; {
  try {
    const movie = await queries.addMovie(ctx.request.body);
    if (movie.length) {
      ctx.status = 201;
      ctx.body = {
        status: 'success',
        data: movie
      };
    } else {
      ctx.status = 400;
      ctx.body = {
        status: 'error',
        message: 'Something went wrong.'
      };
    }
  } catch (err) {
    console.log(err)
  }
})
</code></pre>

<p>DB query:</p>

<pre><code class="javascript">function addMovie(movie) {
  return knex('movies')
  .insert(movie)
  .returning('*');
}
</code></pre>

<p>What if the payload does not include the correct keys? Add a new <code>it</code> block:</p>

<pre><code class="javascript">it('should throw an error if the payload is malformed', (done) =&gt; {
  chai.request(server)
  .post('/api/v1/movies')
  .send({
    name: 'Titanic'
  })
  .end((err, res) =&gt; {
    // there should an error
    should.exist(err);
    // there should be a 400 status code
    res.status.should.equal(400);
    // the response should be JSON
    res.type.should.equal('application/json');
    // the JSON response body should have a
    // key-value pair of {"status": "error"}
    res.body.status.should.eql('error');
    // the JSON response body should have a message key
    should.exist(res.body.message);
    done();
  });
});
</code></pre>

<p>Then update the route handler:</p>

<pre><code class="javascript">router.post(`${BASE_URL}`, async (ctx) =&gt; {
  try {
    const movie = await queries.addMovie(ctx.request.body);
    if (movie.length) {
      ctx.status = 201;
      ctx.body = {
        status: 'success',
        data: movie
      };
    } else {
      ctx.status = 400;
      ctx.body = {
        status: 'error',
        message: 'Something went wrong.'
      };
    }
  } catch (err) {
    ctx.status = 400;
    ctx.body = {
      status: 'error',
      message: err.message || 'Sorry, an error has occurred.'
    };
  }
})
</code></pre>

<h3>PUT</h3>

<p>Test:</p>

<pre><code class="javascript">describe('PUT /api/v1/movies', () =&gt; {
  it('should return the movie that was updated', (done) =&gt; {
    knex('movies')
    .select('*')
    .then((movie) =&gt; {
      const movieObject = movie[0];
      chai.request(server)
      .put(`/api/v1/movies/${movieObject.id}`)
      .send({
        rating: 9
      })
      .end((err, res) =&gt; {
        // there should be no errors
        should.not.exist(err);
        // there should be a 200 status code
        res.status.should.equal(200);
        // the response should be JSON
        res.type.should.equal('application/json');
        // the JSON response body should have a
        // key-value pair of {"status": "success"}
        res.body.status.should.eql('success');
        // the JSON response body should have a
        // key-value pair of {"data": 1 movie object}
        res.body.data[0].should.include.keys(
          'id', 'name', 'genre', 'rating', 'explicit'
        );
        // ensure the movie was in fact updated
        const newMovieObject = res.body.data[0];
        newMovieObject.rating.should.not.eql(movieObject.rating);
        done();
      });
    });
  });
});
</code></pre>

<p>Route handler:</p>

<pre><code class="javascript">router.put(`${BASE_URL}/:id`, async (ctx) =&gt; {
  try {
    const movie = await queries.updateMovie(ctx.params.id, ctx.request.body);
    if (movie.length) {
      ctx.status = 200;
      ctx.body = {
        status: 'success',
        data: movie
      };
    } else {
      ctx.status = 404;
      ctx.body = {
        status: 'error',
        message: 'That movie does not exist.'
      };
    }
  } catch (err) {
    ctx.status = 400;
    ctx.body = {
      status: 'error',
      message: err.message || 'Sorry, an error has occurred.'
    };
  }
})
</code></pre>

<p>DB query:</p>

<pre><code class="javascript">function updateMovie(id, movie) {
  return knex('movies')
  .update(movie)
  .where({ id: parseInt(id) })
  .returning('*');
}
</code></pre>

<p>Did you notice that we are already handling a case where the movie does not exist in the route handler? Let&rsquo;s add a test for that:</p>

<pre><code class="javascript">it('should throw an error if the movie does not exist', (done) =&gt; {
  chai.request(server)
  .put('/api/v1/movies/9999999')
  .send({
    rating: 9
  })
  .end((err, res) =&gt; {
    // there should an error
    should.exist(err);
    // there should be a 404 status code
    res.status.should.equal(404);
    // the response should be JSON
    res.type.should.equal('application/json');
    // the JSON response body should have a
    // key-value pair of {"status": "error"}
    res.body.status.should.eql('error');
    // the JSON response body should have a
    // key-value pair of {"message": "That movie does not exist."}
    res.body.message.should.eql('That movie does not exist.');
    done();
  });
});
</code></pre>

<h3>DELETE</h3>

<p>Test:</p>

<pre><code class="javascript">describe('DELETE /api/v1/movies/:id', () =&gt; {
  it('should return the movie that was deleted', (done) =&gt; {
    knex('movies')
    .select('*')
    .then((movies) =&gt; {
      const movieObject = movies[0];
      const lengthBeforeDelete = movies.length;
      chai.request(server)
      .delete(`/api/v1/movies/${movieObject.id}`)
      .end((err, res) =&gt; {
        // there should be no errors
        should.not.exist(err);
        // there should be a 200 status code
        res.status.should.equal(200);
        // the response should be JSON
        res.type.should.equal('application/json');
        // the JSON response body should have a
        // key-value pair of {"status": "success"}
        res.body.status.should.eql('success');
        // the JSON response body should have a
        // key-value pair of {"data": 1 movie object}
        res.body.data[0].should.include.keys(
          'id', 'name', 'genre', 'rating', 'explicit'
        );
        // ensure the movie was in fact deleted
        knex('movies').select('*')
        .then((updatedMovies) =&gt; {
          updatedMovies.length.should.eql(lengthBeforeDelete - 1);
          done();
        });
      });
    });
  });
  it('should throw an error if the movie does not exist', (done) =&gt; {
    chai.request(server)
    .delete('/api/v1/movies/9999999')
    .end((err, res) =&gt; {
      // there should an error
      should.exist(err);
      // there should be a 404 status code
      res.status.should.equal(404);
      // the response should be JSON
      res.type.should.equal('application/json');
      // the JSON response body should have a
      // key-value pair of {"status": "error"}
      res.body.status.should.eql('error');
      // the JSON response body should have a
      // key-value pair of {"message": "That movie does not exist."}
      res.body.message.should.eql('That movie does not exist.');
      done();
    });
  });
});
</code></pre>

<p>Route handler:</p>

<pre><code class="javascript">router.delete(`${BASE_URL}/:id`, async (ctx) =&gt; {
  try {
    const movie = await queries.deleteMovie(ctx.params.id);
    if (movie.length) {
      ctx.status = 200;
      ctx.body = {
        status: 'success',
        data: movie
      };
    } else {
      ctx.status = 404;
      ctx.body = {
        status: 'error',
        message: 'That movie does not exist.'
      };
    }
  } catch (err) {
    ctx.status = 400;
    ctx.body = {
      status: 'error',
      message: err.message || 'Sorry, an error has occurred.'
    };
  }
})
</code></pre>

<pre><code class="javascript">function deleteMovie(id) {
  return knex('movies')
  .del()
  .where({ id: parseInt(id) })
  .returning('*');
}
</code></pre>

<p>Run the tests to ensure all pass:</p>

<pre><code>routes : index
  GET /
    âœ“ should return json

routes : movies
  GET /api/v1/movies
    âœ“ should return all movies
  GET /api/v1/movies/:id
    âœ“ should respond with a single movie
    âœ“ should throw an error if the movie does not exist
  POST /api/v1/movies
    âœ“ should return the movie that was added
    âœ“ should throw an error if the payload is malformed
  PUT /api/v1/movies
    âœ“ should return the movie that was updated
    âœ“ should throw an error if the movie does not exist
  DELETE /api/v1/movies/:id
    âœ“ should return the movie that was deleted
    âœ“ should throw an error if the movie does not exist

Sample Test
  âœ“ should pass


11 passing (697ms)
</code></pre>

<h2>Next Steps</h2>

<p>With that, you now have a basic Koa RESTful API up and running.</p>

<p>Test your knowledge by adding additional test cases and error handlers to cover anything missed. You may also want to convert an existing Express app over to Koa. Check out the <a href="https://github.com/koajs/examples">Koa Examples</a> repo for more code examples.</p>

<p>Add end-to-end tests with <a href="http://mherman.org/blog/2017/03/19/functional-testing-with-testcafe/#.WZxCvnd95E4">TestCafe</a>.</p>

<p>Finally, this tutorial took advantage of async/await functions in Koa version 2. If you&rsquo;re interested in comparing this pattern to the generator pattern found in Koa 1, review the code in the <a href="https://github.com/mjhea0/koa-api">Koa API</a> repo.</p>

<p>Grab the final code from the <a href="https://github.com/mjhea0/node-koa-api">node-koa-api</a> repo. There&rsquo;s <a href="http://mherman.org/presentations/node-koa-api">slides</a> as well.</p>

<p>Please add questions and/or comments below. Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Developing Microservices - Node, React, and Docker]]></title>
    <link href="http://mherman.org/blog/2017/05/11/developing-microservices-node-react-docker/"/>
    <updated>2017-05-11T08:16:46-06:00</updated>
    <id>http://mherman.org/blog/2017/05/11/developing-microservices-node-react-docker</id>
    <content type="html"><![CDATA[<p>In this post you will learn how to quickly spin up a reproducible development environment with Docker to manage a number of Node.js microservices.</p>

<div style="text-align:center;">
  <img src="http://mherman.org/images/blog/docker-microservices.png" style="max-width: 100%; border:0; box-shadow: none;" alt="microservice architecture">
</div>


<p><br></p>

<p>This post assumes prior knowledge of the following topics. Refer to the resources for more info:</p>

<table>
<thead>
<tr>
<th> Topic            </th>
<th> Resource </th>
</tr>
</thead>
<tbody>
<tr>
<td> Docker           </td>
<td> <a href="https://docs.docker.com/engine/getstarted/">Get started with Docker</a> </td>
</tr>
<tr>
<td> Docker Compose   </td>
<td> <a href="https://docs.docker.com/compose/gettingstarted/">Get started with Docker Compose</a> </td>
</tr>
<tr>
<td> Node/Express API </td>
<td> <a href="http://mherman.org/blog/2016/09/12/testing-node-and-express">Testing Node and Express</a> </td>
</tr>
<tr>
<td> React </td>
<td> <a href="https://github.com/mjhea0/node-workshop/blob/master/w2/lessons/03-react.md">React Intro</a></td>
</tr>
<tr>
<td> TestCafe </td>
<td> <a href="http://mherman.org/blog/2017/03/19/functional-testing-with-testcafe">Functional Testing With TestCafe</a></td>
</tr>
<tr>
<td> Swagger </td>
<td> <a href="http://mherman.org/blog/2016/05/26/swagger-and-nodejs/">Swagger and NodeJS</a></td>
</tr>
</tbody>
</table>


<blockquote><p><strong>NOTE</strong>: Looking for a slightly easier implementation? Check out my previous post - <a href="http://mherman.org/blog/2017/04/18/developing-and-testing-microservices-with-docker">Developing and Testing Microservices With Docker</a>.</p></blockquote>

<h2>Contents</h2>

<ol>
<li>Objectives</li>
<li>Architecture</li>
<li>Project Setup</li>
<li>Users Service</li>
<li>Web Service - part 1</li>
<li>Movies Service</li>
<li>Web Service - part 2</li>
<li>Workflow</li>
<li>Test Setup</li>
<li>Swagger Setup</li>
<li>Next Steps</li>
</ol>


<h2>Objectives</h2>

<p>By the end of this tutorial, you should be able to&hellip;</p>

<ol>
<li>Configure and run microservices locally with Docker and Docker Compose</li>
<li>Utilize <a href="https://docs.docker.com/engine/tutorials/dockervolumes/">volumes</a> to mount your code into a container</li>
<li>Run unit and integration tests inside a Docker container</li>
<li>Test the entire set of services with functional, end-to-end tests</li>
<li>Debug a running Docker container</li>
<li>Enable services running in different containers to talk to one other</li>
<li>Secure your services via JWT-based authentication</li>
<li>Work with React running inside a Docker Container</li>
<li>Configure Swagger to interact with a service</li>
</ol>


<h2>Architecture</h2>

<p>The end goal of this post is to organize the technologies from the above image into the following containers and services:</p>

<table>
<thead>
<tr>
<th> Name             </th>
<th> Service </th>
<th> Container </th>
<th> Tech                 </th>
</tr>
</thead>
<tbody>
<tr>
<td> Web              </td>
<td> Web     </td>
<td> web       </td>
<td> React, React-Router  </td>
</tr>
<tr>
<td> Movies API       </td>
<td> Movies  </td>
<td> movies    </td>
<td> Node, Express        </td>
</tr>
<tr>
<td> Movies DB        </td>
<td> Movies  </td>
<td> movies-db </td>
<td> Postgres             </td>
</tr>
<tr>
<td> Swagger          </td>
<td> Movies  </td>
<td> swagger   </td>
<td> Swagger UI           </td>
</tr>
<tr>
<td> Users API        </td>
<td> Users   </td>
<td> users     </td>
<td> Node, Express        </td>
</tr>
<tr>
<td> Users DB         </td>
<td> Users   </td>
<td> users-db  </td>
<td> Postgres             </td>
</tr>
<tr>
<td> Functional Tests </td>
<td> Test    </td>
<td> n/a       </td>
<td> TestCafe             </td>
</tr>
</tbody>
</table>


<p>Let&rsquo;s get started!</p>

<h2>Project Setup</h2>

<p>Start by cloning the base project and then checking out the first tag:</p>

<pre><code class="sh">$ git clone https://github.com/mjhea0/microservice-movies
$ cd microservice-movies
$ git checkout tags/v1
</code></pre>

<p>Overall project structure:</p>

<pre><code class="sh">.
â”œâ”€â”€ services
â”‚Â Â  â”œâ”€â”€ movies
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ src
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ db
â”‚Â Â  â”‚Â Â  â””â”€â”€ swagger
â”‚Â Â  â”œâ”€â”€ users
â”‚Â Â  â”‚Â Â  â””â”€â”€ src
â”‚Â Â  â”‚Â Â      â””â”€â”€ db
â”‚Â Â  â””â”€â”€ web
â””â”€â”€ tests
</code></pre>

<p>Before we add Docker, be sure to review the code so that you have a basic understanding of how everything works. Feel free to test these services as well&hellip;</p>

<p><em>Users:</em></p>

<ul>
<li>Navigate to &ldquo;services/users&rdquo;</li>
<li><code>npm install</code></li>
<li>update the <code>start</code> script within <em>package.json</em> to <code>"gulp --gulpfile gulpfile.js"</code></li>
<li><code>npm start</code></li>
<li>Open <a href="http://localhost:3000/users/ping">http://localhost:3000/users/ping</a> in your browser</li>
</ul>


<p><em>Movies:</em></p>

<ul>
<li>Navigate to &ldquo;services/movies&rdquo;</li>
<li><code>npm install</code></li>
<li>update the <code>start</code> script within <em>package.json</em> to <code>"gulp --gulpfile gulpfile.js"</code></li>
<li><code>npm start</code></li>
<li>Open <a href="http://localhost:3000/movies/ping">http://localhost:3000/movies/ping</a> in your browser</li>
</ul>


<p><em>Web:</em></p>

<ul>
<li>Navigate to &ldquo;services/web&rdquo;</li>
<li><code>npm install</code></li>
<li><code>npm start</code></li>
<li>Open <a href="http://localhost:3006">http://localhost:3006</a> in your browser. You should see the log in page.</li>
</ul>


<p>Next, add a <em>docker-compose.yml</em> file to the project root. This file is used by Docker Compose to link multiple services together. With one command it will spin up all the containers we need and enable them to communicate with one another (as needed).</p>

<p>With that, let&rsquo;s get each service going, making sure to test as we go&hellip;</p>

<h2>Users Service</h2>

<p>We&rsquo;ll start with the database since the API is dependent on it being up&hellip;</p>

<h3>Database</h3>

<p>First, add a <em>Dockerfile</em> to &ldquo;services/users/src/db&rdquo;:</p>

<pre><code>FROM postgres

# run create.sql on init
ADD create.sql /docker-entrypoint-initdb.d
</code></pre>

<p>Here, we extend the official Postgres image by adding a SQL file to the &ldquo;docker-entrypoint-initdb.d&rdquo; directory in the container, which will execute on init.</p>

<p>Then update the <em>docker-compose.yml</em> file:</p>

<pre><code>version: '2.1'

services:

  users-db:
    container_name: users-db
    build: ./services/users/src/db
    ports:
      - '5433:5432' # expose ports - HOST:CONTAINER
    environment:
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=postgres
    healthcheck:
      test: exit 0
</code></pre>

<p>This config will create a container called <code>users-db</code>, from the <em>Dockerfile</em> found in &ldquo;services/users/src/db&rdquo;. (Directories are relative to the <em>docker-compose.yml</em> file.)</p>

<p>Once spun up, environment variables will be added and an exit code of <code>0</code> will be sent after it&rsquo;s successfully up and running. Postgres will be available on port <code>5433</code> on the host machine and on port <code>5432</code> for other services.</p>

<blockquote><p><strong>NOTE:</strong> Use <code>expose</code>, rather than <code>ports</code>, if you just want Postgres available to other services but not the host machine:</p>

<pre><code>expose:
  - "5432"
</code></pre></blockquote>

<p>Take note of the version used - <code>2.1</code>. This does not relate directly to the version of Docker Compose installed; instead, it specifies the file format that you want to use.</p>

<p>Fire up the container:</p>

<pre><code class="sh">$ docker-compose up --build -d users-db
</code></pre>

<p>Once up, let&rsquo;s run a quick sanity check. Enter the shell:</p>

<pre><code class="sh">$ docker-compose run users-db bash
</code></pre>

<p>Then run <code>env</code> to ensure that the proper environment variables are set. You can also check out the &ldquo;docker-entrypoint-initdb.d&rdquo; directory:</p>

<pre><code class="sh"># cd docker-entrypoint-initdb.d/
# ls
create.sql
</code></pre>

<p><code>exit</code> when done.</p>

<h3>API</h3>

<p>Turning to the API, add a <em>Dockerfile</em> to &ldquo;services/users&rdquo;, making sure to review the comments:</p>

<pre><code>FROM node:latest

# set working directory
RUN mkdir /usr/src/app
WORKDIR /usr/src

# add `/usr/src/node_modules/.bin` to $PATH
ENV PATH /usr/src/node_modules/.bin:$PATH

# install and cache app dependencies
ADD package.json /usr/src/package.json
RUN npm install

# start app
CMD ["npm", "start"]
</code></pre>

<blockquote><p><strong>NOTE</strong>: Be sure to take advantage of Docker&rsquo;s layered <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/#build-cache">cache</a> system, to speed up build times, by adding the <em>package.json</em> and installing the dependencies <strong>before</strong> adding the app&rsquo;s source files. For more on this, check out <a href="http://bitjudo.com/blog/2014/03/13/building-efficient-dockerfiles-node-dot-js/">Building Efficient Dockerfiles - Node.js</a>.</p></blockquote>

<p>Then add the <code>users-service</code> to the <em>docker-compose.yml</em> file:</p>

<pre><code>users-service:
  container_name: users-service
  build: ./services/users/
  volumes:
    - './services/users:/usr/src/app'
    - './services/users/package.json:/usr/src/package.json'
  ports:
    - '3000:3000' # expose ports - HOST:CONTAINER
  environment:
    - DATABASE_URL=postgres://postgres:postgres@users-db:5432/users_dev
    - DATABASE_TEST_URL=postgres://postgres:postgres@users-db:5432/users_test
    - NODE_ENV=${NODE_ENV}
    - TOKEN_SECRET=changeme
  depends_on:
    users-db:
      condition: service_healthy
  links:
    - users-db
</code></pre>

<p>What&rsquo;s happening here?</p>

<ul>
<li><code>volumes</code>: <a href="https://docs.docker.com/engine/tutorials/dockervolumes/">volumes</a> are used to mount a directory inside a container so that you can make modifications to the code without having to rebuild the image. This should be a default in your local development environment so you quickly get feedback on code changes.</li>
<li><code>depends_on</code>: <a href="https://docs.docker.com/compose/compose-file/#dependson">depends_on</a> specifies the order in which to start services. In this case, the <code>users-service</code> will wait for the <code>users-db</code> to fire up successfully (with an exit code of <code>0</code>) before it starts.</li>
<li><code>links</code>: With <a href="https://docs.docker.com/compose/compose-file/#links">links</a> you can link to services running in other containers. So, with this config, code inside the <code>users-service</code> will be able to access the database via <code>users-db:5432</code>.</li>
</ul>


<blockquote><p><strong>NOTE:</strong> Curious about the difference between <code>depends_on</code> and <code>links</code>? Check out the following <a href="http://stackoverflow.com/a/39658359/1799408">Stack Overflow discussion</a> for more info.</p></blockquote>

<p>Set the <code>NODE_ENV</code> environment variable:</p>

<pre><code class="sh">$ export NODE_ENV=development
</code></pre>

<p>Build the image and spin up the container:</p>

<pre><code class="sh">$ docker-compose up --build -d users-service
</code></pre>

<blockquote><p><strong>NOTE:</strong> Keep in mind that Docker Compose handles both the build and run times. This can be confusing. For example, take a look at the current docker-compose.yml file - What is happening at the build time? How about the run time? How do you know?</p></blockquote>

<p>Once up, create a new file in the project root called <em>init_db.sh</em> and add the Knex migrate and seed commands:</p>

<pre><code class="sh">#!/bin/sh

docker-compose run users-service knex migrate:latest --env development --knexfile app/knexfile.js
docker-compose run users-service knex seed:run --env development --knexfile app/knexfile.js
</code></pre>

<p>Then apply the migrations and add the seed:</p>

<pre><code class="sh">$ sh init_db.sh
Using environment: development
Batch 1 run: 1 migrations
/src/src/db/migrations/20170504191016_users.js
Using environment: development
Ran 1 seed files
/src/src/db/seeds/users.js
</code></pre>

<p>Test:</p>

<table>
<thead>
<tr>
<th> Endpoint        </th>
<th> HTTP Method </th>
<th> CRUD Method </th>
<th> Result        </th>
</tr>
</thead>
<tbody>
<tr>
<td> /users/ping     </td>
<td> GET         </td>
<td> READ        </td>
<td> <code>pong</code>        </td>
</tr>
<tr>
<td> /users/register </td>
<td> POST        </td>
<td> CREATE      </td>
<td> add a user    </td>
</tr>
<tr>
<td> /users/login    </td>
<td> POST        </td>
<td> CREATE      </td>
<td> log in a user </td>
</tr>
<tr>
<td> /users/user     </td>
<td> GET         </td>
<td> READ        </td>
<td> get user info </td>
</tr>
</tbody>
</table>


<pre><code class="sh">$ http POST http://localhost:3000/users/register username=foo password=bar
$ http POST http://localhost:3000/users/login username=foo password=bar
</code></pre>

<blockquote><p><strong>NOTE:</strong> <code>http</code> in the above commands is part of the <a href="https://httpie.org/">HTTPie</a> library, which is a wrapper on top of cURL.</p></blockquote>

<p>In both cases you should see a <code>status</code> of <code>success</code> along with a <code>token</code>, i.e. -</p>

<pre><code class="sh">{
    "status": "success",
    "token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9"
}
</code></pre>

<p>Finally, run the unit and integration tests:</p>

<pre><code class="sh">$ docker-compose run users-service npm test
</code></pre>

<p>You should see:</p>

<pre><code>routes : index
  GET /does/not/exist
    âœ“ should throw an error

routes : users
  POST /users/register
    âœ“ should register a new user (178ms)
  POST /users/login
    âœ“ should login a user (116ms)
    âœ“ should not login an unregistered user
    âœ“ should not login a valid user with incorrect password (125ms)
  GET /users/user
    âœ“ should return a success (114ms)
    âœ“ should throw an error if a user is not logged in

auth : helpers
  comparePass()
    âœ“ should return true if the password is correct (354ms)
    âœ“ should return false if the password is correct (315ms)
    âœ“ should return false if the password empty (305ms)

auth : local
  encodeToken()
    âœ“ should return a token
  decodeToken()
    âœ“ should return a payload


12 passing (4s)
</code></pre>

<p>Check the test specs for more info. That&rsquo;s it! Let&rsquo;s move on to the web service&hellip;</p>

<h2>Web Service - part 1</h2>

<p>With our users service up and running, we can turn our attention to the client-side and spin up the React app inside a container to test authentication.</p>

<blockquote><p><strong>NOTE:</strong> The React code is ported from <a href="https://github.com/blackstc/intro-react-redux-omdb">intro-react-redux-omdb</a> and <a href="https://github.com/etmoore/communikey">communikey</a> written by <a href="https://www.linkedin.com/in/charlieblackstock/">Charlie Blackstock</a> and <a href="https://www.linkedin.com/in/etmoore1/">Evan Moore</a>, respectively - two of my former students.</p></blockquote>

<p>Add a <em>Dockerfile</em> to &ldquo;services/web&rdquo;:</p>

<pre><code>FROM node:latest

# set working directory
RUN mkdir /usr/src/app
WORKDIR /usr/src/app

# add `/usr/src/app/node_modules/.bin` to $PATH
ENV PATH /usr/src/app/node_modules/.bin:$PATH

# install and cache app dependencies
ADD package.json /usr/src/app/package.json
RUN npm install
RUN npm install react-scripts@0.9.5 -g

# start app
CMD ["npm", "start"]
</code></pre>

<p>As of 05/10/2017 the <a href="http://www.omdbapi.com/">OMDb API</a> is private, so you have to donate at least $1 to gain access. Once you have an API Key, update the <code>API_URL</code> in <em>services/web/src/App.jsx</em>:</p>

<pre><code class="javascript">const API_URL = 'http://www.omdbapi.com/?apikey=addyourkey&amp;s='
</code></pre>

<p>Then update the <em>docker-compose.yml</em> file like so:</p>

<pre><code>web-service:
  container_name: web-service
  build: ./services/web/
  volumes:
    - './services/web:/usr/src/app'
    - '/usr/src/app/node_modules'
  ports:
    - '3007:3006' # expose ports - HOST:CONTAINER
  environment:
    - NODE_ENV=${NODE_ENV}
  depends_on:
    users-service:
      condition: service_started
  links:
    - users-service
</code></pre>

<blockquote><p><strong>NOTE:</strong> To prevent the volume - <code>/usr/src/app</code> - from overriding the <em>package.json</em>, we used a data volume - <code>/usr/src/app/node_modules</code>. This may or may not be necessary, depending on the order in which you set up your image and containers. Check out <a href="http://dchua.com/2016/02/07/getting-npm-packages-to-be-installed-with-docker-compose/">Getting npm packages to be installed with docker-compose</a> for more.</p></blockquote>

<p>Build the image and fire up the container:</p>

<pre><code class="sh">$ docker-compose up --build -d web-service
</code></pre>

<blockquote><p><strong>NOTE:</strong> To avoid dealing with too much configuration (babel and webpack), the React app uses <a href="https://github.com/facebookincubator/create-react-app">Create React App</a>.</p></blockquote>

<p>Open your browser and navigate to <a href="http://localhost:3007">http://localhost:3007</a>. You should see the login page:</p>

<div style="text-align:center;">
  <img src="http://mherman.org/images/blog/microservice-movies-login.png" style="max-width: 100%; border:0; box-shadow: none;" alt="login page">
</div>


<p>Log in with -</p>

<ul>
<li>username: <code>foo</code></li>
<li>password: <code>bar</code></li>
</ul>


<p>Once logged in you should see:</p>

<div style="text-align:center;">
  <img src="http://mherman.org/images/blog/microservice-movies-search.png" style="max-width: 100%; border:0; box-shadow: none;" alt="search page">
</div>


<p>Within <em>services/web/src/App.jsx</em>, let&rsquo;s take a quick look at the AJAX request in the <code>loginUser()</code> method:</p>

<pre><code class="javascript">loginUser (userData, callback) {
  /*
    why? http://localhost:3000/users/login
    why not? http://users-service:3000/users/login
   */
  return axios.post('http://localhost:3000/users/login', userData)
  .then((res) =&gt; {
    window.localStorage.setItem('authToken', res.data.token)
    window.localStorage.setItem('user', res.data.user)
    this.setState({ isAuthenticated: true })
    this.createFlashMessage('You successfully logged in! Welcome!')
    this.props.history.push('/')
    this.getMovies()
  })
  .catch((error) =&gt; {
    callback('Something went wrong')
  })
}
</code></pre>

<p>Why do we use <code>localhost</code> rather than the name of the container, <code>users-service</code>? This request is originating outside the container, on the host. Keep in mind, that if, this request was originating inside the container, we would need to use the container name rather than <code>localhost</code>, since <code>localhost</code> would refer back to the container itself in that situation.</p>

<p>Make sure you can log out and register as well.</p>

<p>Next, let&rsquo;s spin up the movies service so that end users can save movies to a collection&hellip;</p>

<h2>Movies Service</h2>

<p>Set up for the movies service is nearly the same as the users service. Try this on your own to check your understanding:</p>

<ol>
<li>Database

<ul>
<li>add a <em>Dockerfile</em></li>
<li>update the <em>docker-compose.yml</em></li>
<li>spin up the container</li>
<li>test</li>
</ul>
</li>
<li>API

<ul>
<li>add a <em>Dockerfile</em></li>
<li>update the <em>docker-compose.yml</em> (make sure to link the service with the database and the users service and update the exposed ports - <code>3001</code> for the api, <code>5434</code> for the db)</li>
<li>spin up the container</li>
<li>apply migrations and seeds</li>
<li>test</li>
</ul>
</li>
</ol>


<blockquote><p><strong>NOTE:</strong> Need help? Grab the code from the <a href="https://github.com/mjhea0/microservice-movies/releases/tag/v2">v2</a> tag of the <a href="https://github.com/mjhea0/microservice-movies">microservice-movies</a> repo.</p></blockquote>

<p>The movies database image should take much less time to build than the users database. Why?</p>

<p>With the containers up, let&rsquo;s test out the endpoints&hellip;</p>

<table>
<thead>
<tr>
<th> Endpoint      </th>
<th> HTTP Method </th>
<th> CRUD Method </th>
<th> Result                    </th>
</tr>
</thead>
<tbody>
<tr>
<td> /movies/ping  </td>
<td> GET         </td>
<td> READ        </td>
<td> <code>pong</code>                    </td>
</tr>
<tr>
<td> /movies/user  </td>
<td> GET         </td>
<td> READ        </td>
<td> get all movies by user    </td>
</tr>
<tr>
<td> /movies       </td>
<td> POST        </td>
<td> CREATE      </td>
<td> add a single movie        </td>
</tr>
</tbody>
</table>


<p>Start with opening the browser to <a href="http://localhost:3001/movies/ping">http://localhost:3001/movies/ping</a>. You should see <code>pong</code>! Try <a href="http://localhost:3001/movies/user">http://localhost:3001/movies/user</a>:</p>

<pre><code class="json">{
  "status": "Please log in"
}
</code></pre>

<p>Since you need to be authenticated to access the other routes, let&rsquo;s test them out by running the integration tests:</p>

<pre><code class="sh">$ docker-compose run movies-service npm test
</code></pre>

<p>You should see:</p>

<pre><code class="sh">routes : index
  GET /does/not/exist
    âœ“ should throw an error

Movies API Routes
  GET /movies/ping
    âœ“ should return "pong"
  GET /movies/user
    âœ“ should return saved movies
  POST /movies
    âœ“ should create a new movie


4 passing (818ms)
</code></pre>

<p>Check the test specs for more info.</p>

<h2>Web Service - part 2</h2>

<p>Turn to the <em>docker-compose.yml</em> file. Update the <code>links</code> and <code>depends_on</code> keys for the <code>web-service</code>:</p>

<pre><code>depends_on:
  users-service:
    condition: service_started
  movies-service:
    condition: service_started
links:
  - users-service
  - movies-service
</code></pre>

<p>Why?</p>

<p>Next, update the container:</p>

<pre><code class="sh">$ docker-compose up -d web-service
</code></pre>

<p>Let&rsquo;s test this out in the browser! Open <a href="http://localhost:3007/">http://localhost:3007/</a>. Register a new user and then add some movies to the collection.</p>

<p>Be sure to view the collection as well:</p>

<div style="text-align:center;">
  <img src="http://mherman.org/images/blog/microservice-movies-collection.png" style="max-width: 100%; border:0; box-shadow: none;" alt="collection page">
</div>


<p>Open <em>services/movies/src/routes/_helpers.js</em> and take note of the <code>ensureAuthenticated()</code> method:</p>

<pre><code class="javascript">let ensureAuthenticated = (req, res, next) =&gt; {
  if (!(req.headers &amp;&amp; req.headers.authorization)) {
    return res.status(400).json({ status: 'Please log in' });
  }
  const options = {
    method: 'GET',
    uri: 'http://users-service:3000/users/user',
    json: true,
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${req.headers.authorization.split(' ')[1]}`,
    },
  };
  return request(options)
  .then((response) =&gt; {
    req.user = response.user;
    return next();
  })
  .catch((err) =&gt; { return next(err); });
};
</code></pre>

<p>Why does the uri point to <code>users-service</code> and not <code>localhost</code>?</p>

<h2>Workflow</h2>

<p>Start by checking out the <em>Workflow</em> section from <a href="http://mherman.org/blog/2017/04/18/developing-and-testing-microservices-with-docker/">Developing and Testing Microservices With Docker</a>. Experiment with live reloading on a code change and debugging a running container with <code>console.log</code>.</p>

<p>Add a header to the collection page:</p>

<div style="text-align:center;">
  <img src="http://mherman.org/images/blog/microservice-movies-collection-updated.png" style="max-width: 100%; border:0; box-shadow: none;" alt="collection page with header">
</div>


<p>Run the logs - <code>docker-compose logs -f web-service</code> - and then make a change to one of the components that breaks compilation:</p>

<pre><code class="sh">web-service       | Compiling...
web-service       | Failed to compile.
web-service       |
web-service       | Error in ./src/components/SavedMovies.jsx
web-service       |
web-service       | /usr/src/app/src/components/SavedMovies.jsx
web-service       |   10:13  error  'Link' is not defined  react/jsx-no-undef
web-service       |
web-service       | âœ– 1 problem (1 error, 0 warnings)
web-service       |
web-service       |
</code></pre>

<p>Correct the error:</p>

<pre><code class="sh">web-service       |
web-service       | Compiling...
web-service       | Compiled successfully!
</code></pre>

<p>Continue to experiment with adding and updating the React app until you feel comfortable working with it inside the container.</p>

<h2>Test Setup</h2>

<p>Thus far we&rsquo;ve only tested each individual microservice with unit and integration tests. Let&rsquo;s turn our attention to functional, end-to-end tests to test the entire system. For this, we&rsquo;ll use <a href="https://devexpress.github.io/testcafe/">TestCafe</a>.</p>

<blockquote><p><strong>NOTE:</strong> Don&rsquo;t want to use TestCafe? Check out the <a href="https://github.com/mjhea0/node-docker-api/tree/master/tests">code</a> for using Mocha, Chai, Request, and Cheerio (all within a container) for testing.</p></blockquote>

<p>Let&rsquo;s be lazy and install TestCafe globally:</p>

<pre><code class="sh">$ npm install testcafe@0.15.0 -g
</code></pre>

<p>Then run the tests:</p>

<pre><code class="sh">$ testcafe firefox tests/**/*.js
</code></pre>

<p>You should see:</p>

<pre><code class="sh">testcafe firefox tests/**/*.js
 Running tests in:
 - Firefox 53.0.0 / Mac OS X 10.11.0

 /login
 âœ“ users should be able to log in and out


 1 passed (3s)
</code></pre>

<blockquote><p><strong>NOTE:</strong> Interested in running the tests from within a container? Check out the <a href="https://devexpress.github.io/testcafe/documentation/using-testcafe/installing-testcafe.html#using-testcafe-docker-image">official TestCafe docs</a> for more info on using TestCafe with Docker.</p></blockquote>

<p>To simplify the test workflow, add a <em>test.sh</em> file to the project root:</p>

<pre><code class="sh">#!/bin/bash

fails=''

inspect() {
  if [ $1 -ne 0 ] ; then
    fails="${fails} $2"
  fi
}

docker-compose run users-service npm test
inspect $? users-service

docker-compose run movies-service npm test
inspect $? movies-service

testcafe firefox tests/**/*.js
inspect $? e2e

if [ -n "${fails}" ];
  then
    echo "Tests failed: ${fails}"
    exit 1
  else
    echo "Tests passed!"
    exit 0
fi
</code></pre>

<p>Run the tests:</p>

<pre><code class="sh">$ sh test.sh
</code></pre>

<h2>Swagger Setup</h2>

<p>Add a <em>Dockerfile</em> to &ldquo;services/movies/swagger&rdquo;:</p>

<pre><code>FROM node:latest

# set working directory
RUN mkdir /usr/src/app
WORKDIR /usr/src/app

# add `/usr/src/node_modules/.bin` to $PATH
ENV PATH /usr/src/app/node_modules/.bin:$PATH

# install and cache app dependencies
ADD package.json /usr/src/app/package.json
RUN npm install

# start app
CMD ["npm", "start"]
</code></pre>

<p>Update <em>docker-compose.yml</em>:</p>

<pre><code>swagger:
  container_name: swagger
  build: ./services/movies/swagger/
  volumes:
    - './services/movies/swagger:/usr/src/app'
    - '/usr/src/app/node_modules'
  ports:
    - '3003:3001' # expose ports - HOST:CONTAINER
  environment:
    - NODE_ENV=${NODE_ENV}
  depends_on:
    users-service:
      condition: service_started
    movies-service:
      condition: service_started
  links:
    - users-service
    - movies-service
</code></pre>

<p>Fire it up:</p>

<pre><code class="sh">$ docker-compose up -d --build swagger
</code></pre>

<p>Navigate to <a href="http://localhost:3003/docs">http://localhost:3003/docs</a> and test it out:</p>

<div style="text-align:center;">
  <img src="http://mherman.org/images/blog/microservice-movies-swagger.png" style="max-width: 100%; border:0; box-shadow: none;" alt="swagger docs">
</div>


<p>Now you just need to incorporate support for JWT-based auth and add the remaining endpoints!</p>

<h2>Next Steps</h2>

<p>What&rsquo;s next?</p>

<ol>
<li><em>React App</em> - The React app could use some love. Add styles. Fix bugs. Update the flash messages so that only one is displayed at a time. Write tests. Build new features. Add Redux. The sky&rsquo;s the limit. Contact me if you&rsquo;d like to pair!</li>
<li><em>Swagger</em> - Add JWT-based auth and add additional endpoints from the movies service.</li>
<li><em>Dockerfiles</em> - Read <a href="https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/">Best practices for writing Dockerfiles</a>, by the Docker team, and refactor as necessary.</li>
<li><em>Production</em> - Want to deploy on AWS? Check out the <a href="http://mherman.org/blog/2017/09/18/on-demand-test-environments-with-docker-and-aws-ecs">On-Demand Environments With Docker and AWS ECS</a> blog post.</li>
</ol>


<p>Grab the final code from the <a href="https://github.com/mjhea0/microservice-movies/releases/tag/v2">v2</a> tag of the <a href="https://github.com/mjhea0/microservice-movies">microservice-movies</a> repo. Please add questions and/or comments below. Thereâ€™s slides too! Check them out <a href="http://mherman.org/microservice-movies">here</a>, if interested.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flask for Node Developers]]></title>
    <link href="http://mherman.org/blog/2017/04/26/flask-for-node-developers/"/>
    <updated>2017-04-26T08:46:05-06:00</updated>
    <id>http://mherman.org/blog/2017/04/26/flask-for-node-developers</id>
    <content type="html"><![CDATA[<p><strong>Today we&rsquo;ll be going through how to build a basic CRUD server-side application using Python and <a href="http://flask.pocoo.org/">Flask</a>, geared toward JavaScript developers versed in Node and Express</strong>. Similar to <a href="https://expressjs.com/">Express</a>, <a href="http://flask.pocoo.org/">Flask</a> is a simple, yet powerful micro-framework for Python, perfect for RESTful APIs.</p>

<div style="text-align:center;">
  <img src="http://mherman.org/images/blog/flask-node.png" style="max-width: 100%; border:0; box-shadow: none;" alt="flask and node">
</div>


<p><br></p>

<blockquote><p>This tutorial uses Flask v<a href="https://pypi.python.org/pypi/Flask/0.12.1">0.12.1</a> and Python v<a href="https://www.python.org/downloads/release/python-361/">3.6.1</a>.</p></blockquote>

<h2>Contents</h2>

<ol>
<li>Objectives</li>
<li>Project Setup</li>
<li>Database Setup</li>
<li>Routes</li>
<li>Next Steps</li>
</ol>


<h2>Objectives</h2>

<p>By the end of this tutorial, you should be able to&hellip;</p>

<ol>
<li>Set up a Python development environment</li>
<li>Create and activate a virtual environment</li>
<li>Using SQLite, apply a schema to the database and interact with the database using the basic CRUD functions</li>
<li>Build a CRUD app using Python and Flask</li>
</ol>


<h2>Project Setup</h2>

<p>Before we start, ensure that you have <a href="https://www.python.org/downloads/release/python-361/">Python v3.6.1</a> installed.</p>

<p>Along with Python, we also need <a href="https://pypi.python.org/pypi/pip">pip</a> to install third-party packages from the <a href="https://pypi.python.org/pypi">Python Package Index</a> (aka PyPI), the Python equivalent of npm. Fortunately, this comes pre-installed with all Python versions >= 3.4.</p>

<p>Let&rsquo;s start by creating a new project directory:</p>

<pre><code class="sh">$ mkdir flask-songs-api &amp;&amp; cd flask-songs-api
</code></pre>

<p>Next up, we&rsquo;ll create an isolated virtual environment for installing Python packages specific to our individual project. It&rsquo;s <a href="https://www.python.org/dev/peps/pep-0405/#isolation-from-system-site-packages">standard practice</a> to set up a virtual environment for each project, otherwise there can be compatibility issues with different dependencies.</p>

<pre><code class="sh">$ python3.6 -m venv env
</code></pre>

<p>Next, we need to activate it:</p>

<pre><code class="sh">$ source env/bin/activate
</code></pre>

<p>You should now see <code>env</code> in your prompt, indicating that the virtual environment is activated.</p>

<blockquote><p><strong>NOTE:</strong> Ready to stop developing? Use the <code>deactivate</code> command to deactivate the virtual environment. To activate it again, navigate to the directory and re-run the source command - <code>source env/bin/activate</code>.</p></blockquote>

<p>Now we can install Flask:</p>

<pre><code class="sh">$ pip install Flask==0.12.1
$ pip freeze &gt; requirements.txt
</code></pre>

<p>Now is a great time to add a <em>.gitignore</em>:</p>

<pre><code>env
*.db
</code></pre>

<p>Finally, let&rsquo;s add a main app file, which will handle routing and run our application, along with a file to setup our database schema:</p>

<pre><code class="sh">$ touch app.py models.py
</code></pre>

<h2>Database Setup</h2>

<p>For this tutorial, we will be using <a href="https://www.sqlite.org/">SQLite3</a> since it&rsquo;s part of the <a href="https://docs.python.org/3.5/library/sqlite3.html">Python standard library</a>, requires little (if any) configuration, and is powerful enough for small to mid-size applications (e.g., the majority of web apps).</p>

<p>Start by creating a new database file in your project root:</p>

<pre><code class="sh">$ touch songs.db
</code></pre>

<p>Now start a new SQLite session:</p>

<pre><code class="sh">$ sqlite3 songs.db
</code></pre>

<p>Then run:</p>

<pre><code class="sh">sqlite&gt; .databases
</code></pre>

<p>You should see a file path to your database file, which is empty at the moment and ready for us to create a schema and data to. To create a schema, add the following code to <em>models.py</em>:</p>

<pre><code class="python">import sqlite3


def drop_table():
    with sqlite3.connect('songs.db') as connection:
        c = connection.cursor()
        c.execute("""DROP TABLE IF EXISTS songs;""")
    return True


def create_db():
    with sqlite3.connect('songs.db') as connection:
        c = connection.cursor()
        table = """CREATE TABLE songs(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            artist TEXT NOT NULL,
            title TEXT NOT NULL,
            rating INTEGER NOT NULL
        );
        """
        c.execute(table)
    return True


if __name__ == '__main__':
    drop_table()
    create_db()
</code></pre>

<p>This will drop the songs table if it exists and put a new one in place with the schema we&rsquo;ve defined here. If you have any issues with your database later on, or if you just want to start fresh, you can always run this script to recreate the database. Back in the terminal, exit SQLite and then run the script to create our table:</p>

<pre><code class="sh">sqlite&gt; .exit
$ python models.py
</code></pre>

<p>Let&rsquo;s check if that actually worked:</p>

<pre><code class="sh">$ sqlite3 songs.db
sqlite&gt; .table
songs
sqlite&gt; .schema
CREATE TABLE songs(
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            artist TEXT NOT NULL,
            title TEXT NOT NULL,
            rating INTEGER NOT NULL
        );
sqlite&gt; .exit
</code></pre>

<p>Great! So, now that our database is set up correctly, we can move on to setting up our app&rsquo;s route handlers. For this post, we won&rsquo;t be going into database migrations but if you ever want to change the schema, you can use <a href="https://flask-migrate.readthedocs.io/en/latest/">Flask-Migrate</a>.</p>

<h2>Routes</h2>

<p>Let&rsquo;s start with an overview of the routes, following RESTful principles:</p>

<table>
<thead>
<tr>
<th> Endpoint              </th>
<th> Result                </th>
<th> CRUD   </th>
<th> HTTP   </th>
</tr>
</thead>
<tbody>
<tr>
<td> <code>/api/songs</code>          </td>
<td> Returns all songs     </td>
<td> Read   </td>
<td> GET    </td>
</tr>
<tr>
<td> <code>/api/song/&lt;song_id&gt;</code> </td>
<td> Returns a single song </td>
<td> Read   </td>
<td> GET    </td>
</tr>
<tr>
<td> <code>/api/songs</code>          </td>
<td> Adds a single song    </td>
<td> Create </td>
<td> POST   </td>
</tr>
<tr>
<td> <code>/api/song/&lt;song_id&gt;</code> </td>
<td> Updates a single song </td>
<td> Update </td>
<td> PUT    </td>
</tr>
<tr>
<td> <code>/api/song/&lt;song_id&gt;</code> </td>
<td> Deletes a single song </td>
<td> Delete </td>
<td> DELETE </td>
</tr>
</tbody>
</table>


<p>But first, before creating any routes, add the following code to <em>app.py</em>:</p>

<pre><code class="python">import sqlite3
from flask import Flask


app = Flask(__name__)


if __name__ == '__main__':
    app.debug = True
    app.run()
</code></pre>

<p>Here we imported <code>sqlite3</code> along with the main <a href="http://flask.pocoo.org/docs/0.12/api/#application-object">Flask application object</a>, <code>Flask</code>, which creates an instance of Flask in our application. The Flask application object acts as the central object, which we can use as a way of calling our view functions, adding our URL rules, template configuration and much more. With that instance we can run the application using the <code>run</code> <a href="http://flask.pocoo.org/docs/0.12/api/#flask.Flask.run">method</a>. We also set the <a href="http://flask.pocoo.org/docs/0.12/api/#flask.Flask.debug">debug flag</a> to <code>True</code> so that the server live reloads when code changes and provides an interactive debugger when an exception is thrown.</p>

<blockquote><p><strong>NOTE:</strong> <code>if __name__ == '__main__'</code> states that this source file is our main program. Any files imported from other modules will have their name set to their module name. This is because you may sometimes have modules that could be executed directly as well as be imported into a main app file. This line means that the code in those modules will only execute when you want to run the module as a program, and not have it execute when someone just wants to import a module and execute it themselves.</p></blockquote>

<p>Finally, it&rsquo;s important to note that any imports must go at the top of our <em>app.py</em> file. These must come before anything else in order to be used later on in our file.</p>

<p>Now, add the routes:</p>

<pre><code class="python">import sqlite3
from flask import Flask, request


app = Flask(__name__)


@app.route('/api/songs', methods=['GET', 'POST'])
def collection():
    if request.method == 'GET':
        pass  # Handle GET all Request
    elif request.method == 'POST':
        pass  # Handle POST request


@app.route('/api/song/&lt;song_id&gt;', methods=['GET', 'PUT', 'DELETE'])
def resource(song_id):
    if request.method == 'GET':
        pass  # Handle GET single request
    elif request.method == 'PUT':
        pass  # Handle UPDATE request
    elif request.method == 'DELETE':
        pass  # Handle DELETE request


if __name__ == '__main__':
    app.debug = True
    app.run()
</code></pre>

<p>We imported <code>request</code>, which handles, well, HTTP requests (no surprises there). Let&rsquo;s look at each method, staring with a POST:</p>

<h3>POST</h3>

<p>The first thing we need to do is add data to our database. Once we&rsquo;ve done this, we can start building and testing the rest of our database/CRUD functions.</p>

<p>The process is simple:</p>

<ol>
<li>Create a connection to our database</li>
<li>Execute our SQL query to add a song</li>
<li>Commit the changes to the database</li>
<li>Close the database connection</li>
<li>Return an object</li>
</ol>


<p>We can write a single function to handle this. Let&rsquo;s place all helper functions underneath the routes, to keep things nicely separated:</p>

<pre><code class="python"># helper functions

def add_song(artist, title, rating):
    try:
        with sqlite3.connect('songs.db') as connection:
            cursor = connection.cursor()
            cursor.execute("""
                INSERT INTO songs (artist, title, rating) values (?, ?, ?);
                """, (artist, title, rating,))
            result = {'status': 1, 'message': 'Song Added'}
    except:
        result = {'status': 0, 'message': 'error'}
    return result
</code></pre>

<p>Now we can just use this function in our route handler, passing the correct arguments from an incoming POST request:</p>

<pre><code class="python">@app.route('/api/songs', methods=['GET', 'POST'])
def collection():
    if request.method == 'GET':
        pass  # Handle GET all Request
    elif request.method == 'POST':
        data = request.form
        result = add_song(data['artist'], data['title'], data['rating'])
        return jsonify(result)
</code></pre>

<p>So, we grabbed the values from the incoming form request, then called the <code>add_song()</code> function to add that song to the database, and, finally, returned the appropriate JSON response.</p>

<p>Make sure to add <code>jsonify</code> to the imports in order to send a JSON response back:</p>

<pre><code class="python">from flask import Flask, request, jsonify
</code></pre>

<p>Ready to test? Start the server in one terminal window:</p>

<pre><code class="sh">$ python app.py
</code></pre>

<p>Now, in another window use CURL to send a POST request:</p>

<pre><code class="sh">$ curl --data "artist='Hudson Mohawke'&amp;title='Cbat'&amp;rating=5" http://localhost:5000/api/songs
</code></pre>

<p>If all went well, you should see the follwing response, indicating that the song was added to the database:</p>

<pre><code class="sh">{
  "message": "Song Added",
  "status": 1
}
</code></pre>

<p>Just to be on the safe side, let&rsquo;s double-check that. Kill the server, then open a SQLite session from within your project directory:</p>

<pre><code class="sh">$ sqlite3 songs.db
</code></pre>

<p>Now run the following SQL query:</p>

<pre><code class="sh">sqlite&gt; SELECT * FROM songs ORDER BY id desc;
</code></pre>

<p>You should see:</p>

<pre><code>1|'Hudson Mohawke'|'Cbat'|5`
</code></pre>

<p>Okay. We have officially added our first song! Add a couple more before moving on to reading data (GET). Don&rsquo;t forget to run the Flask server before running the CURL commands!</p>

<pre><code class="sh">$ curl --data "artist='Beastie Boys'&amp;title='Sabotage'&amp;rating=4" http://localhost:5000/api/songs
$ curl --data "artist='Gregori Klosman'&amp;title='Jaws'&amp;rating=3" http://localhost:5000/api/songs
</code></pre>

<h3>GET</h3>

<p>We&rsquo;ll start with our GET all route, e.g. - <code>api/songs</code>. We need to connect to the database, execute the appropriate SQL query, and then return all of the songs from that query:</p>

<pre><code class="python">def get_all_songs():
    with sqlite3.connect('songs.db') as connection:
        cursor = connection.cursor()
        cursor.execute("SELECT * FROM songs ORDER BY id desc")
        all_songs = cursor.fetchall()
        return all_songs
</code></pre>

<p>Next up, we have to change our route handler to now call this function and then send back JSON:</p>

<pre><code class="python">@app.route('/api/songs', methods=['GET', 'POST'])
def collection():
    if request.method == 'GET':
        all_songs = get_all_songs()
        return json.dumps(all_songs)
    elif request.method == 'POST':
        data = request.form
        result = add_song(data['artist'], data['title'], data['rating'])
        return jsonify(result)
</code></pre>

<p>Did you notice that we&rsquo;re using the <code>json</code> module? This is also from the Python standard library, which allows us to convert the &lsquo;list&rsquo;-like format of data we get back from SQLite3 into a JSON object. Just don&rsquo;t forget to import it:</p>

<pre><code class="python">import json
</code></pre>

<p>To test, we can simply navigate to <a href="http://127.0.0.1:5000/api/songs">http://127.0.0.1:5000/api/songs</a> in the browser to check if all our songs are there.</p>

<p>You should see something like:</p>

<pre><code class="json">[
  [
    3,
    "'Gregori Klosman'",
    "'Jaws'",
    3
  ],
  [
    2,
    "'Beastie Boys'",
    "'Sabotage'",
    4
  ],
  [
    1,
    "'Hudson Mohawke'",
    "'Cbat'",
    5
  ]
]
</code></pre>

<p>Now that we can GET all songs, let&rsquo;s build a function to GET just a single song. This function will take a parameter of <code>song_id</code>, create a connection to our database, find that song with a SQL query, and then return that song with JSON:</p>

<pre><code class="python">def get_single_song(song_id):
    with sqlite3.connect('songs.db') as connection:
        cursor = connection.cursor()
        cursor.execute("SELECT * FROM songs WHERE id = ?", (song_id,))
        song = cursor.fetchone()
        return song
</code></pre>

<p>We can update our route with a <code>song_id</code> as a parameter, and send back the single song:</p>

<pre><code class="py">@app.route('/api/song/&lt;song_id&gt;', methods=['GET', 'PUT', 'DELETE'])
def resource(song_id):
    if request.method == 'GET':
        song = get_single_song(song_id)
        return json.dumps(song)
    elif request.method == 'PUT':
        pass  # Handle UPDATE request
    elif request.method == 'DELETE':
        pass  # Handle DELETE request
</code></pre>

<p>If you now point your browser to <a href="http://127.0.0.1:5000/api/song/2">http://127.0.0.1:5000/api/song/2</a> you should see the JSON object for our song with an id of <code>2</code> in the database:</p>

<pre><code class="json">[
    2,
    "'Beastie Boys'",
    "'Sabotage'",
    4
]
</code></pre>

<p>If you try to put in an id that we don&rsquo;t have in the database currently, you will just get <code>null</code> displayed on the page instead of a JSON object.</p>

<p>We can CREATE a song, READ all songs, and READ a single song. Only two more routes to go&hellip;</p>

<h3>PUT</h3>

<p>A major function that we&rsquo;re missing is the ability to edit data that&rsquo;s already present in our database. We do this using a PUT request by taking incoming data with an id passed through the URL, finding the object in our database with that particular id, and then updating it.</p>

<p>Let&rsquo;s start with an edit function, which takes in the song id, artist, title, and rating as arguments:</p>

<pre><code class="python">def edit_song(song_id, artist, title, rating):
    try:
        with sqlite3.connect('songs.db') as connection:
            connection.execute("UPDATE songs SET artist = ?, title = ?, rating = ? WHERE ID = ?;", (artist, title, rating, song_id,))
            result = {'status': 1, 'message': 'SONG Edited'}
    except:
        result = {'status': 0, 'message': 'Error'}
    return result
</code></pre>

<p>Now we can edit our route to pass in the data from the PUT request:</p>

<pre><code class="py">@app.route('/api/song/&lt;song_id&gt;', methods=['GET', 'PUT', 'DELETE'])
def resource(song_id):
    if request.method == 'GET':
        song = get_single_song(song_id)
        return json.dumps(song)
    elif request.method == 'PUT':
        data = request.form
        result = edit_song(
            song_id, data['artist'], data['title'], data['rating'])
        return jsonify(result)
    elif request.method == 'DELETE':
        pass  # Handle DELETE request
</code></pre>

<p>So if we test this route out with CURL:</p>

<pre><code class="sh">$ curl -X PUT --data "artist='Van Halen'&amp;title='Hot for Teacher'&amp;rating=3" localhost:5000/api/song/2
</code></pre>

<p>We should see:</p>

<pre><code class="sh">{
  "message": "SONG Edited",
  "status": 1
}
</code></pre>

<p>We can (err, should) make sure that edit is reflected in the database:</p>

<pre><code class="sh">$ sqlite3 songs.db
sqlite&gt; SELECT * FROM songs ORDER BY id desc;

3|'Gregori Klosman'|'Jaws'|3
2|'Van Halen'|'Hot for Teacher'|3
1|'Hudson Mohawke'|'Cbat'|5
</code></pre>

<p>We can edit songs at will!</p>

<h3>Delete</h3>

<p>The last thing we have left to do is our DELETE route. We need to be able to remove data from our database. Let&rsquo;s first add in a song we can then delete using CURL in the terminal:</p>

<pre><code class="sh">$ curl --data "artist='The Flaming Lips'&amp;title='Buggin'&amp;rating=2" http://localhost:5000/api/songs
</code></pre>

<p>Make sure it&rsquo;s in our database:</p>

<pre><code class="sh">$ sqlite3 songs.db
sqlite&gt; SELECT * FROM songs ORDER BY id desc;

4|'The Flaming Lips'|'Buggin'|2
3|'Gregori Klosman'|'Jaws'|3
2|'Van Halen'|'Hot for Teacher'|3
1|'Hudson Mohawke'|'Cbat'|5
</code></pre>

<p>We need to build a delete function:</p>

<pre><code class="python">def delete_song(song_id):
    try:
        with sqlite3.connect('songs.db') as connection:
            connection.execute("DELETE FROM songs WHERE ID = ?;", (song_id,))
            result = {'status': 1, 'message': 'SONG Deleted'}
    except:
        result = {'status': 0, 'message': 'Error'}
    return result
</code></pre>

<p>And now let&rsquo;s add in our delete route:</p>

<pre><code class="py">@app.route('/api/song/&lt;song_id&gt;', methods=['GET', 'PUT', 'DELETE'])
def resource(song_id):
    if request.method == 'GET':
        song = get_single_song(song_id)
        return json.dumps(song)
    elif request.method == 'PUT':
        data = request.form
        result = edit_song(
            song_id, data['artist'], data['title'], data['rating'])
        return jsonify(result)
    elif request.method == 'DELETE':
        result = delete_song(song_id)
        return jsonify(result)
</code></pre>

<p>Test it with CURL:</p>

<pre><code class="sh">$ curl -X DELETE localhost:5000/api/song/4

{
  "message": "SONG Deleted",
  "status": 1
}
</code></pre>

<p>And finally, go back into our database and really make sure it&rsquo;s gone:</p>

<pre><code class="sh">$ sqlite3 songs.db
sqlite&gt; SELECT * FROM songs ORDER BY id desc;

3|'Gregori Klosman'|'Jaws'|3
2|'Van Halen'|'Hot for Teacher'|3
1|'Hudson Mohawke'|'Cbat'|5
</code></pre>

<p>Boom! So we now have all of our routes doing <em>exactly</em> what we want them to do. We can add songs, get the songs back (all, or just a single song), edit a song, and remove a song. That&rsquo;s some quality CRUD right there.</p>

<h2>Next Steps</h2>

<ol>
<li><em>Error Handling</em>: The code we have right now is completely reliant on the data coming through correctly, but what if there&rsquo;s something missing when the user sends a POST request? For example, what would happen if the artist name was missing? Right now we aren&rsquo;t handling errors that may come up. Think about how we can send information back to the user if not all fields are present in the POST or PUT request, and how you could be clear in the error messages we send back to the user.</li>
<li><em>Server-side Templating</em>: Build out your client-side by adding <a href="http://flask.pocoo.org/docs/0.12/quickstart/#static-files">static files</a> and <a href="http://flask.pocoo.org/docs/0.12/quickstart/#rendering-templates">templates</a>.</li>
<li><em>Database Management:</em> Refactor SQLite and vanilla SQL out of your application and add in Postgres, <a href="http://flask-sqlalchemy.pocoo.org/2.1/">Flask-SQLAlchemy</a> (for communicating with the database), and <a href="https://flask-migrate.readthedocs.io/en/latest/">Flask-Migrate</a> (for migrations). Check out <a href="https://github.com/mjhea0/flask-songs-api/tree/master/_live">this example</a> of how to use Postgres and Flask-SQLAlchemy.</li>
</ol>


<p>Grab the code from the <a href="https://github.com/mjhea0/flask-songs-api">flask-songs-api</a> repo. Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Developing and Testing Microservices With Docker]]></title>
    <link href="http://mherman.org/blog/2017/04/18/developing-and-testing-microservices-with-docker/"/>
    <updated>2017-04-18T08:16:46-06:00</updated>
    <id>http://mherman.org/blog/2017/04/18/developing-and-testing-microservices-with-docker</id>
    <content type="html"><![CDATA[<p>Often, when developing applications with a microservice architecture, you cannot fully test out all services until you deploy to a staging server. This takes much too long to get feedback. Docker helps to speed up this process by making it easier to link together small, independent services locally.</p>

<p><strong>In this article we&rsquo;ll look at how to configure and test a number of services locally with <a href="https://docs.docker.com/">Docker</a> and <a href="https://docs.docker.com/compose/">Docker Compose</a>. We&rsquo;ll also look at workflow and how to interact with and debug containers.</strong></p>

<div style="text-align:center;">
  <img src="http://mherman.org/images/blog/node-docker-api.png" style="max-width: 100%; border:0; box-shadow: none;" alt="microservice architecture">
</div>


<p><br></p>

<p>This post assumes prior knowledge of the following topics. Refer to the resources for more info:</p>

<table>
<thead>
<tr>
<th> Topic            </th>
<th> Resource </th>
</tr>
</thead>
<tbody>
<tr>
<td> Docker           </td>
<td> <a href="https://docs.docker.com/engine/getstarted/">Get started with Docker</a> </td>
</tr>
<tr>
<td> Docker Compose   </td>
<td> <a href="https://docs.docker.com/compose/gettingstarted/">Get started with Docker Compose</a> </td>
</tr>
<tr>
<td> Node/Express API </td>
<td> <a href="http://mherman.org/blog/2016/09/12/testing-node-and-express">Testing Node and Express</a> </td>
</tr>
</tbody>
</table>


<blockquote><p><strong>NOTE</strong>: Looking for a more advanced implementation with React? Check out my other post - <a href="http://mherman.org/blog/2017/05/11/developing-microservices-node-react-docker">Developing Microservices - Node, React, and Docker</a>.</p></blockquote>

<h2>Contents</h2>

<ol>
<li>Objectives</li>
<li>Project Setup</li>
<li>Docker Config</li>
<li>Postgres Setup</li>
<li>Users Service Setup</li>
<li>Locations Service Setup</li>
<li>Web Setup</li>
<li>Workflow</li>
<li>Testing</li>
<li>Test Setup</li>
<li>Next Steps</li>
</ol>


<h2>Objectives</h2>

<p>By the end of this tutorial, you should be able to&hellip;</p>

<ol>
<li>Configure and run a set of microservices locally with Docker and Docker Compose</li>
<li>Utilize <a href="https://docs.docker.com/engine/tutorials/dockervolumes/">volumes</a> to mount your code into a container</li>
<li>Run unit and integration tests inside a Docker container</li>
<li>Set up a separate container for functional tests</li>
<li>Debug a running Docker container</li>
<li>Utilize <a href="https://docs.docker.com/compose/compose-file/#links">links</a> for inter-container communication (AJAX)</li>
<li>Secure your services via JWT-based authentication</li>
</ol>


<h2>Project Setup</h2>

<p>Start by cloning the base project and then checking out the first tag:</p>

<pre><code class="sh">$ git clone https://github.com/mjhea0/node-docker-api
$ cd node-docker-api
$ git checkout tags/v1
</code></pre>

<p>Take a quick look at the structure, broken down by service:</p>

<pre><code class="sh">â”œâ”€â”€ services
â”‚Â Â  â”œâ”€â”€ locations
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ gulpfile.js
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ knexfile.js
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ package.json
â”‚Â Â  â”‚Â Â  â”œâ”€â”€ src
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ app.js
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ db
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ connection.js
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ create.sql
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ migrations
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 20170405114746_locations.js
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ queries.js
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ seeds
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â      â””â”€â”€ locations.js
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ routes
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â”œâ”€â”€ _helpers.js
â”‚Â Â  â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ locations.js
â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ server.js
â”‚Â Â  â”‚Â Â  â””â”€â”€ tests
â”‚Â Â  â”‚Â Â      â””â”€â”€ integration
â”‚Â Â  â”‚Â Â          â”œâ”€â”€ routes.index.test.js
â”‚Â Â  â”‚Â Â          â””â”€â”€ routes.locations.test.js
â”‚Â Â  â””â”€â”€ users
â”‚Â Â      â”œâ”€â”€ gulpfile.js
â”‚Â Â      â”œâ”€â”€ knexfile.js
â”‚Â Â      â”œâ”€â”€ npm-debug.log
â”‚Â Â      â”œâ”€â”€ package.json
â”‚Â Â      â”œâ”€â”€ src
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ app.js
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ auth
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ _helpers.js
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ local.js
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ db
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ connection.js
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ create.sql
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”œâ”€â”€ migrations
â”‚Â Â      â”‚Â Â  â”‚Â Â  â”‚Â Â  â””â”€â”€ 20170403223908_users.js
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ seeds
â”‚Â Â      â”‚Â Â  â”‚Â Â      â””â”€â”€ users.js
â”‚Â Â      â”‚Â Â  â”œâ”€â”€ routes
â”‚Â Â      â”‚Â Â  â”‚Â Â  â””â”€â”€ users.js
â”‚Â Â      â”‚Â Â  â””â”€â”€ server.js
â”‚Â Â      â””â”€â”€ tests
â”‚Â Â          â”œâ”€â”€ integration
â”‚Â Â          â”‚Â Â  â”œâ”€â”€ routes.index.test.js
â”‚Â Â          â”‚Â Â  â””â”€â”€ routes.users.test.js
â”‚Â Â          â””â”€â”€ unit
â”‚Â Â              â”œâ”€â”€ auth.helpers.test.js
â”‚Â Â              â””â”€â”€ auth.local.test.js
â”œâ”€â”€ tests
â”‚Â Â  â”œâ”€â”€ main.test.js
â”‚Â Â  â””â”€â”€ package.json
â””â”€â”€ web
    â”œâ”€â”€ gulpfile.js
    â”œâ”€â”€ package.json
    â””â”€â”€ src
        â”œâ”€â”€ app.js
        â”œâ”€â”€ public
        â”‚Â Â  â”œâ”€â”€ main.css
        â”‚Â Â  â””â”€â”€ main.js
        â”œâ”€â”€ routes
        â”‚Â Â  â”œâ”€â”€ _helpers.js
        â”‚Â Â  â””â”€â”€ index.js
        â”œâ”€â”€ server.js
        â””â”€â”€ views
            â”œâ”€â”€ _base.html
            â”œâ”€â”€ error.html
            â”œâ”€â”€ login.html
            â”œâ”€â”€ main.html
            â”œâ”€â”€ nav.html
            â”œâ”€â”€ register.html
            â””â”€â”€ user.html
</code></pre>

<p>Before we Dockerize the services, feel free to test the locations and/or users services&hellip;</p>

<p>Users:</p>

<ol>
<li>Navigate to &ldquo;services/users&rdquo;</li>
<li><code>npm install</code></li>
<li><code>node src/server.js</code></li>
<li>Open <a href="http://localhost:3000/users/ping">http://localhost:3000/users/ping</a> in your browser</li>
</ol>


<p>Locations:</p>

<ol>
<li>Navigate to &ldquo;services/locations&rdquo;</li>
<li><code>npm install</code></li>
<li><code>node src/server.js</code></li>
<li>Open <a href="http://localhost:3001/locations/ping">http://localhost:3001/locations/ping</a> in your browser</li>
</ol>


<p>Kill the servers once done.</p>

<h2>Docker Config</h2>

<p>Add a <em>docker-compose.yml</em> file to the project root, which is a config file used by Docker Compose to link multiple services together:</p>

<pre><code>version: '2.1'
</code></pre>

<blockquote><p><strong>NOTE:</strong> Why 2.1? <a href="https://docs.docker.com/compose/compose-file/compose-file-v2/#version-21">Answer</a>.</p></blockquote>

<p>Then add a <em>.dockerignore</em> to the &ldquo;services/locations&rdquo;, &ldquo;services/locations/src/db&rdquo;, &ldquo;services/users&rdquo;, &ldquo;services/users/src/db&rdquo;, &ldquo;tests&rdquo;, and &ldquo;web&rdquo; directories:</p>

<pre><code>.git
.gitignore
README.md
docker-compose.yml
node_modules
</code></pre>

<p>With that, let&rsquo;s set up each service individually, testing as we go&hellip;</p>

<h2>Postgres Setup</h2>

<p>Add a <em>Dockerfile</em> to &ldquo;services/locations/src/db&rdquo; and &ldquo;services/users/src/db&rdquo;:</p>

<pre><code>FROM postgres

# run create.sql on init
ADD create.sql /docker-entrypoint-initdb.d
</code></pre>

<p>Then update <em>docker-compose.yml</em>:</p>

<pre><code>version: '2.1'

services:

  users-db:
    container_name: users-db
    build: ./services/users/src/db
    ports:
      - '5433:5432'
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=admin
    healthcheck:
      test: exit 0

  locations-db:
    container_name: locations-db
    build: ./services/locations/src/db
    ports:
      - '5434:5432'
    environment:
      - POSTGRES_USER=admin
      - POSTGRES_PASSWORD=admin
    healthcheck:
      test: exit 0
</code></pre>

<p>Here, we create two new containers called <code>users-db</code> and <code>locations-db</code>, from the <em>Dockerfiles</em> found in &ldquo;services/users/src/db&rdquo; and &ldquo;services/locations/src/db&rdquo;, respectively. We also add environment variables, expose ports, and send an exit code <code>0</code> once they are successfully up and running - which will be used by other services.</p>

<p>To fire up the containers, run:</p>

<pre><code class="sh">$ docker-compose up --build -d
</code></pre>

<p>Once up, you can get a quick sanity check, by entering the shell:</p>

<pre><code class="sh">$ docker-compose run users-db bash
# exit
$ docker-compose run locations-db bash
# exit
</code></pre>

<h2>Users Service Setup</h2>

<p>Again, add a <em>Dockerfile</em> to &ldquo;services/users&rdquo;, making sure to review the comments:</p>

<pre><code>FROM node:latest

# set working directory
RUN mkdir /src
WORKDIR /src

# install app dependencies
ENV PATH /src/node_modules/.bin:$PATH
ADD package.json /src/package.json
RUN npm install

# start app
CMD ["npm", "start"]
</code></pre>

<p>Add the <code>users-service</code> to the <em>docker-compose.yml</em> file:</p>

<pre><code>users-service:
  container_name: users-service
  build: ./services/users/
  volumes:
    - './services/users:/src/app'
    - './services/users/package.json:/src/package.json'
  ports:
    - '3000:3000'
  environment:
    - DATABASE_URL=postgres://admin:admin@users-db:5432/node_docker_api_users_dev
    - DATABASE_TEST_URL=postgres://admin:admin@users-db:5432/node_docker_api_users_test
    - NODE_ENV=${NODE_ENV}
    - TOKEN_SECRET=changeme
  depends_on:
    users-db:
      condition: service_healthy
  links:
    - users-db
</code></pre>

<p>What&rsquo;s new here?</p>

<ol>
<li><code>volumes</code>: <a href="https://docs.docker.com/engine/tutorials/dockervolumes/">volumes</a> are used to mount a directory into a container so that you can make changes to the code without having to build a new image. This should be a default in your local development environment so you can get quick feedback on code changes.</li>
<li><code>depends_on</code>: <a href="https://docs.docker.com/compose/compose-file/#dependson">depends_on</a> is used to start services in a specific order. So, the <code>users-service</code> will wait for the <code>users-db</code> to fire up successfully (with an exit code of <code>0</code>) before it starts.</li>
<li><code>links</code>: With <a href="https://docs.docker.com/compose/compose-file/#links">links</a>, code inside the <code>users-service</code> can access the database via <code>users-db:5432</code>.</li>
</ol>


<p>Set the <code>NODE_ENV</code> environment variable:</p>

<pre><code class="sh">$ export NODE_ENV=development
</code></pre>

<p>Spin up the container:</p>

<pre><code class="sh">$ docker-compose up --build -d users-service
</code></pre>

<p>Once up, create a new file in the project root called <em>migrate.sh</em> and add the Knex migrate and seed commands:</p>

<pre><code class="sh">#!/bin/sh

docker-compose run users-service knex migrate:latest --env development --knexfile app/knexfile.js
docker-compose run users-service knex seed:run --env development --knexfile app/knexfile.js
</code></pre>

<p>Then run it:</p>

<pre><code class="sh">$ sh migrate.sh
</code></pre>

<p>Test:</p>

<table>
<thead>
<tr>
<th> Endpoint        </th>
<th> HTTP Method </th>
<th> CRUD Method </th>
<th> Result        </th>
</tr>
</thead>
<tbody>
<tr>
<td> /users/ping     </td>
<td> GET         </td>
<td> READ        </td>
<td> <code>pong</code>        </td>
</tr>
<tr>
<td> /users/register </td>
<td> POST        </td>
<td> CREATE      </td>
<td> add a user    </td>
</tr>
<tr>
<td> /users/login    </td>
<td> POST        </td>
<td> CREATE      </td>
<td> log in a user </td>
</tr>
<tr>
<td> /users/user     </td>
<td> GET         </td>
<td> READ        </td>
<td> get user info </td>
</tr>
</tbody>
</table>


<pre><code class="sh">$ http POST http://localhost:3000/users/register username=michael password=herman
$ http POST http://localhost:3000/users/login username=michael password=herman
</code></pre>

<blockquote><p><strong>NOTE:</strong> <code>http</code> in the above commands is part of the <a href="https://httpie.org/">HTTPie</a> library, which is a wrapper on top of cURL.</p></blockquote>

<h2>Locations Service Setup</h2>

<p>Add the <em>Dockerfile</em>:</p>

<pre><code>FROM node:latest

# set working directory
RUN mkdir /src
WORKDIR /src

# install app dependencies
ENV PATH /src/node_modules/.bin:$PATH
ADD package.json /src/package.json
RUN npm install

# start app
CMD ["npm", "start"]
</code></pre>

<p>Add the service to <em>docker-compose</em>:</p>

<pre><code>locations-service:
  container_name: locations-service
  build: ./services/locations/
  volumes:
    - './services/locations:/src/app'
    - './services/locations/package.json:/src/package.json'
  ports:
    - '3001:3001'
  environment:
    - DATABASE_URL=postgres://admin:admin@locations-db:5432/node_docker_api_locations_dev     
    - DATABASE_TEST_URL=postgres://admin:admin@locations-db:5432/node_docker_api_locations_test
    - NODE_ENV=${NODE_ENV}
    - TOKEN_SECRET=changeme
    - OPENWEATHERMAP_API_KEY=${OPENWEATHERMAP_API_KEY}
  depends_on:
    locations-db:
      condition: service_healthy
    users-service:
      condition: service_started
  links:
    - locations-db
    - users-service
</code></pre>

<p>Register with the <a href="https://openweathermap.org/api">OpenWeatherMap API</a>, and add the key as an environment variable:</p>

<pre><code class="sh">$ export OPENWEATHERMAP_API_KEY=YOUR_KEY_HERE
</code></pre>

<p>Spin up the container:</p>

<pre><code class="sh">$ docker-compose up --build -d locations-service
</code></pre>

<p>Add the migrate and seed commands to <em>migrate.sh</em>:</p>

<pre><code class="sh">docker-compose run locations-service knex migrate:latest --env development --knexfile app/knexfile.js
docker-compose run locations-service knex seed:run --env development --knexfile app/knexfile.js
</code></pre>

<p>Run it:</p>

<pre><code class="sh">$ sh migrate.sh
</code></pre>

<p>Test:</p>

<table>
<thead>
<tr>
<th> Endpoint         </th>
<th> HTTP Method </th>
<th> CRUD Method </th>
<th> Result                    </th>
</tr>
</thead>
<tbody>
<tr>
<td> /locations/ping  </td>
<td> GET         </td>
<td> READ        </td>
<td> <code>pong</code>                    </td>
</tr>
<tr>
<td> /locations       </td>
<td> GET         </td>
<td> READ        </td>
<td> get all locations         </td>
</tr>
<tr>
<td> /locations/user  </td>
<td> GET         </td>
<td> READ        </td>
<td> get all locations by user </td>
</tr>
<tr>
<td> /locations/:id   </td>
<td> GET         </td>
<td> READ        </td>
<td> get a single location     </td>
</tr>
<tr>
<td> /locations       </td>
<td> POST        </td>
<td> CREATE      </td>
<td> add a single location     </td>
</tr>
<tr>
<td> /locations/:id   </td>
<td> PUT         </td>
<td> UPDATE      </td>
<td> update a single location  </td>
</tr>
<tr>
<td> /locations/:id   </td>
<td> DELETE      </td>
<td> DELETE      </td>
<td> delete a single location  </td>
</tr>
</tbody>
</table>


<pre><code class="sh">$ http GET http://localhost:3001/locations/ping
</code></pre>

<h2>Web Services Setup</h2>

<p>Moving right along&hellip;</p>

<p>Add the <em>Dockerfile</em>:</p>

<pre><code>FROM node:latest

# set working directory
RUN mkdir /src
WORKDIR /src

# install app dependencies
ENV PATH /src/node_modules/.bin:$PATH
ADD package.json /src/package.json
RUN npm install

# start app
CMD ["npm", "start"]
</code></pre>

<p>Add the service to <em>docker-compose</em>:</p>

<pre><code>web:
  container_name: web
  build: ./web/
  volumes:
    - './web:/src/app'
    - './web/package.json:/src/package.json'
  ports:
    - '3003:3003'
  environment:
    - NODE_ENV=${NODE_ENV}
    - SECRET_KEY=changeme
  depends_on:
    users-service:
      condition: service_started
    locations-service:
      condition: service_started
  links:
    - users-service
    - locations-service
</code></pre>

<p>Spin up the container:</p>

<pre><code class="sh">$ docker-compose up --build -d web
</code></pre>

<p>Navigate to <a href="http://localhost:3003">http://localhost:3003</a> in your browser and you should see the login page. Register a new user. Once redirected, you should see:</p>

<div style="text-align:center;">
  <img src="http://mherman.org/images/blog/node-docker-api-browser.png" style="max-width: 100%; border:0; box-shadow: none;" alt="node docker browser view">
</div>


<p><br></p>

<p>Take a look at the AJAX request in the GET <code>/</code> route in <em>web/src/routes/index.js</em>. Why does the <code>uri</code> point to <code>locations-service</code> and not <code>localhost</code>? Well, <code>localhost</code> refers back to the container itself, so you need to set up a <a href="https://docs.docker.com/compose/compose-file/#links">link</a> in the Docker compose - which we&rsquo;ve already done.</p>

<h2>Testing</h2>

<p>Did you notice the unit and integration tests in the &ldquo;services/users/tests&rdquo; and &ldquo;services/locations/tests&rdquo; folders? Well, to run the tests properly, we need to update the <code>NODE_ENV</code> environment variable, since it is currently configured for the development environment.</p>

<pre><code class="sh">$ export NODE_ENV=test
</code></pre>

<p>Update the containers:</p>

<pre><code class="sh">$ docker-compose up -d
</code></pre>

<p>Then run the tests:</p>

<pre><code class="sh">$ docker-compose run users-service npm test
$ docker-compose run locations-service npm test
</code></pre>

<p>Ready to develop again?</p>

<ol>
<li>Update the env variable - <code>export NODE_ENV=development</code></li>
<li>Update the containers - <code>docker-compose up -d</code></li>
</ol>


<h2>Workflow</h2>

<p>Let&rsquo;s quickly look at how to work with code inside the containers&hellip;</p>

<ol>
<li>Live Reloading - Since the code is mounted in the container via a volume, you can make changes to the local code base which will be applied to the code in the container. <a href="https://github.com/remy/nodemon">Nodemon</a> is used (along with Gulp) to restart the app when changes occur.</li>
<li>Debugging - <code>console.log</code> can be used for testing and debugging. Simply add one to your code base and then open the logs&hellip;</li>
<li>Logs - run <code>docker-compose logs -f</code> to view the logs.</li>
</ol>


<blockquote><p><strong>NOTE:</strong> Check out the <a href="https://github.com/mjhea0/node-docker-api">repo</a> to view more commands.</p></blockquote>

<p>Try it out:</p>

<ol>
<li>Run <code>docker-compose logs -f</code> in the terminal</li>
<li>Add <code>console.log('here');</code> to the top of <em>web/src/routes/index.js</em></li>
<li><p>As soon as you save, you should see the following in the terminal:</p>

<pre><code class="`sh"> web  | [18:35:37] [nodemon] restarting due to changes...
 web  | [18:35:37] [nodemon] running tasks...
 web  | [18:35:39] Using gulpfile /src/app/gulpfile.js
 web  | [18:35:39] Starting 'lint'...
 web  | [18:35:40]
 web  | /src/app/src/routes/index.js
 web  |   1:1  warning  Unexpected console statement  no-console
 web  |
 web  | âœ– 1 problem (0 errors, 1 warning)
 web  |
 web  | [18:35:40] Finished 'lint' after 1.69 s
 web  | [18:35:40] [nodemon] starting `node ./src/server`
 web  | here
</code></pre>

<p> Essentially, Nodemon detected changes and restarted the app, which fired the linter and then the server fired back up.</p></li>
</ol>


<h2>Test Setup</h2>

<p>Finally, to set up the last service, add the <em>Dockerfile</em> to the &ldquo;tests&rdquo; folder:</p>

<pre><code>FROM node:latest

# set working directory
RUN mkdir /src
WORKDIR /src

# install app dependencies
ENV PATH /src/node_modules/.bin:$PATH
ADD package.json /src/package.json
RUN npm install
</code></pre>

<p>Then update the <em>docker-compose.yml</em> file:</p>

<pre><code>tests:
  container_name: tests
  build: ./tests/
  volumes:
    - './tests:/src/app'
    - './tests/package.json:/src/package.json'
  depends_on:
    users-service:
      condition: service_started
    locations-service:
      condition: service_started
  links:
    - users-service
    - locations-service
    - web
</code></pre>

<p>Fire up the container:</p>

<pre><code class="sh">$ docker-compose up --build -d tests
</code></pre>

<p>Update the environment variable, update the containers, and then run the tests:</p>

<pre><code class="sh">$ export NODE_ENV=test
$ docker-compose up -d
$ docker-compose run tests npm test
</code></pre>

<h2>Next Steps</h2>

<p>What&rsquo;s next?</p>

<ol>
<li><strong>Dependency management</strong>: Right now we&rsquo;re installing many of the same dependencies over and over again, in multiple containers. How can we manage this better to spin up new containers faster and save disc space? How about a data-only container that just houses dependencies?</li>
<li><strong>Deployment prep</strong>: Set up Docker Machine for spinning up Docker environments, nginx for load balancing, and Consul for service discovery. Update the environment variables for the base URL since these will be different in production. Add an image registry solution and a data-only container for piping logs to&hellip;</li>
<li><strong>Error handling</strong>: Right now errors are being thrown, but there really isn&rsquo;t much info in the response as to why, which makes debugging difficult. Be a good citizen and handle your errors properly since you may not always have access to the code base from a different service.</li>
<li><strong>DRY</strong>: The code could be refactored in places, especially the tests.</li>
</ol>


<p>Grab the final code from the <a href="https://github.com/mjhea0/node-docker-api">node-docker-api</a> repo. Comment below. Cheers!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Functional Testing With TestCafe]]></title>
    <link href="http://mherman.org/blog/2017/03/19/functional-testing-with-testcafe/"/>
    <updated>2017-03-19T16:37:53-06:00</updated>
    <id>http://mherman.org/blog/2017/03/19/functional-testing-with-testcafe</id>
    <content type="html"><![CDATA[<p>Today we are going to dive into the world of functional web testing with <a href="https://devexpress.github.io/testcafe/">TestCafe</a>.</p>

<p>Unlike the majority of other end-to-end (e2e) testing tools, TestCafe is not dependent on Selenium or WebDriver. Instead, it injects scripts into the browser to communicate directly with the DOM and handle events. It works on any modern browser that supports HTML5 without any plugins. Further, it supports all major operating systems and can run simultaneously on multiple browsers and machines.</p>

<p>We will be using:</p>

<ul>
<li>TestCafe v<a href="https://github.com/DevExpress/testcafe/releases/tag/v0.13.0">0.13.0</a></li>
<li>Chrome v<a href="https://chromereleases.googleblog.com/2017/03/stable-channel-update-for-desktop.html">57</a></li>
<li>NodeJS v<a href="https://nodejs.org/docs/v7.6.0/api/all.html">7.6.0</a></li>
</ul>


<p>Please review the <a href="http://devexpress.github.io/testcafe/documentation/getting-started/">Getting Started</a> guide before beginning.</p>

<h2>Contents</h2>

<ol>
<li>Objectives</li>
<li>Project Setup</li>
<li>Writing Tests</li>
<li>Browser Support</li>
<li>Continuous Integration</li>
<li>Next Steps</li>
</ol>


<h2>Objectives</h2>

<p>By the end of this tutorial, you should be able to&hellip;</p>

<ol>
<li>Set up TestCafe with an existing Node app</li>
<li>Write TestCafe tests using the <a href="https://martinfowler.com/bliki/PageObject.html">PageObject</a> pattern</li>
<li>Test a Node application with functional tests</li>
<li>Integrate TestCafe into a continuous integration process</li>
<li>Configure TestCafe to work with a headless browser</li>
</ol>


<h2>Project Setup</h2>

<p>Start by cloning the base project structure:</p>

<pre><code class="sh">$ git clone https://github.com/mjhea0/testcafe-example --branch v1 --single-branch -b master
</code></pre>

<p>Install the dependencies, and then fire up the app by running <code>npm start</code> to make sure all is well. Navigate to <a href="http://localhost:3000/">http://localhost:3000/</a> in your browser and you should see a list of jobs in HTML. Experiment with the app. Add a job. Update a job. Delete a job. This is what we will be testing. Kill the server when done.</p>

<div style="text-align:center;">
  <img src="http://mherman.org/images/blog/node-jobs.png" style="max-width: 100%; border:0; box-shadow: none;" alt="node jobs">
</div>


<p>Install TestCafe:</p>

<pre><code class="sh">$ npm install testcafe@0.13.0 --save-dev
</code></pre>

<p>With that, you can start running tests.</p>

<blockquote><p><strong>NOTE:</strong> If you were using a Selenium-based testing tool you would need to install both Selenium and Web Driver, which can be difficult depending on your system setup.</p></blockquote>

<p>Add a <code>test</code> command to the <code>scripts</code> in <em>package.json</em>:</p>

<pre><code class="json">"scripts": {
  "start": "node ./bin/www",
  "test": "node_modules/testcafe/bin/testcafe.js chrome tests/"
},
</code></pre>

<p>Here, we specified the path to TestCafe in our &ldquo;node_modules&rdquo; folder along with a <a href="http://devexpress.github.io/testcafe/documentation/using-testcafe/command-line-interface.html#browser-list">target browser</a>, <code>chrome</code>, and a  <a href="http://devexpress.github.io/testcafe/documentation/using-testcafe/command-line-interface.html#file-pathglob-pattern">path</a> to where all tests will be located, <code>tests/</code>.</p>

<p>Now, you can use <code>npm test</code> to run TestCafe.</p>

<p>Let&rsquo;s get a test set up. Add a &ldquo;tests&rdquo; folder to the project root, and add an <em>index.js</em> file to it:</p>

<pre><code class="javascript">import { Selector } from 'testcafe';

fixture('Getting Started')
  .page('https://github.com');

test('Find "testcafe-example" repo on GitHub', async (t) =&gt; {
  const repo = Selector('.repo-list &gt; li &gt; div');
  // search github
  await t
    .typeText('form[action="/search"]', 'testcafe-example user:mjhea0')
    .pressKey('enter');
  // check li for results
  await t
    .expect(repo.innerText).contains('mjhea0/testcafe-example');
});
</code></pre>

<p>What&rsquo;s happening?</p>

<ol>
<li>Since <em>all</em> tests are organized into <a href="http://devexpress.github.io/testcafe/documentation/test-api/test-code-structure.html#fixtures">fixtures</a>, we started with a <code>fixture()</code> function.</li>
<li>Next, we specified a start URL - <code>http://devexpress.github.io/testcafe/example</code> - via the <code>page()</code> <a href="http://devexpress.github.io/testcafe/documentation/test-api/test-code-structure.html#specifying-the-start-webpage">method</a>.</li>
<li>From there, we added the test code into a <code>test()</code> <a href="http://devexpress.github.io/testcafe/documentation/test-api/test-code-structure.html#tests">function</a>, which takes an async function along with the <a href="http://devexpress.github.io/testcafe/documentation/test-api/test-code-structure.html#test-controller">test controller</a> object.</li>
<li><code>await</code> is then used to wait for certain <a href="http://devexpress.github.io/testcafe/documentation/test-api/actions/">actions</a> to complete. In this case, we used <code>typeText()</code> and <code>pressKey()</code> to search GitHub.</li>
<li>On the GitHub search results page, we used a <code>Selector()</code> <a href="http://devexpress.github.io/testcafe/documentation/test-api/selecting-page-elements/selectors.html">function</a> to parse the DOM.</li>
<li>Finally, we asserted that the actual results contain the expected results.</li>
</ol>


<blockquote><p><strong>NOTE:</strong> If you&rsquo;re new to <a href="https://github.com/tc39/ecmascript-asyncawait">async/await</a>, check out <a href="https://ponyfoo.com/articles/understanding-javascript-async-await">Understanding JavaScriptâ€™s async await</a>.</p></blockquote>

<p>Try this out! Run <code>npm test</code>. If all goes well Chrome should fire up and execute the test. Once done, you should see something like this in your terminal:</p>

<pre><code class="sh">Running tests in:
- Chrome 57.0.2987 / Mac OS X 10.11.6

Getting Started
âœ“ Find "testcafe-example" repo on GitHub
</code></pre>

<p>Make sense? No? Continue to run the test and review the above steps until it does. Make sure you understand what&rsquo;s happening before moving on.</p>

<h2>Writing Tests</h2>

<p>Add a new file called <em>jobs.js</em> to the &ldquo;tests&rdquo; folder:</p>

<pre><code class="javascript">import { Selector } from 'testcafe';

fixture('Node Jobs')
  .page('http://localhost:3000');

test('All Jobs', async (t) =&gt; {

});
</code></pre>

<p>Then update the <code>test</code> command in <em>package.json</em>:</p>

<pre><code class="json">"test": "node_modules/testcafe/bin/testcafe.js chrome tests/jobs.js --app 'npm start'"
</code></pre>

<p><code>tests/jobs.js</code> ignores the example GitHub test found in <em>index.js</em> so that we can focus just on the tests added to <em>jobs.js</em>. The <code>--app</code> <a href="https://devexpress.github.io/testcafe/documentation/using-testcafe/command-line-interface.html#-a-command---app-command">option</a> is used to launch the Node app so that TestCafe can interact with it.</p>

<p>Try it. You should see the page load in Chrome. With that, let&rsquo;s test each of our app&rsquo;s CRUD functions.</p>

<h3>GET ALL Jobs</h3>

<p>Update <em>jobs.js</em>:</p>

<pre><code class="javascript">import { Selector } from 'testcafe';

fixture('Node Jobs')
  .page('http://localhost:3000');

test('All Jobs', async (t) =&gt; {
  const title = Selector('h1');
  const tableRows = Selector('tbody &gt; tr');
  const addJobButton = Selector('a.btn.btn-primary');
  const firstJob = Selector('tbody &gt; tr').withText('Horse Whisperer');
  // check title, add job button, table rows, and job exists
  await t
    .expect(title.innerText).eql('All Jobs')
    .expect(addJobButton.innerText).eql('Add New Job')
    .expect(tableRows.count).eql(3)
    .expect(firstJob.exists).ok();
});
</code></pre>

<p>What&rsquo;s happening? Review the code above, line by line. It should be fairly straightforward.  Turn to the <a href="https://devexpress.github.io/testcafe/documentation/test-api/selecting-page-elements/">docs</a> for help, adding comments as necessary.</p>

<p>Run:</p>

<pre><code class="sh">Node Jobs
âœ“ All Jobs


1 passed (0s)
</code></pre>

<p>Before moving on, refactor out the selectors so that they can be re-used by other test cases:</p>

<pre><code class="javascript">import { Selector } from 'testcafe';

// selectors
const title = Selector('h1');
const tableRows = Selector('tbody &gt; tr');
const addJobButton = Selector('a.btn.btn-primary');
const firstJob = Selector('tbody &gt; tr').withText('Horse Whisperer');

fixture('Node Jobs')
  .page('http://localhost:3000');

test('All Jobs', async (t) =&gt; {
  // check title, add job button, table rows, and job exists
  await t
    .expect(title.innerText).eql('All Jobs')
    .expect(addJobButton.innerText).eql('Add New Job')
    .expect(tableRows.count).eql(3)
    .expect(firstJob.exists).ok();
});
</code></pre>

<h3>Add Job</h3>

<p>Start by adding a new <code>test()</code> function to <em>jobs.js</em>:</p>

<pre><code class="javascript">test.only('New Job', async (t) =&gt; {

});
</code></pre>

<blockquote><p><strong>NOTE:</strong> Can you guess what <code>only()</code> does? Try running the tests to see. Please review the <a href="https://devexpress.github.io/testcafe/documentation/test-api/test-code-structure.html#skipping-tests">docs</a> for more info.</p></blockquote>

<p>Think about the steps an end user has to go through to add a job:</p>

<ol>
<li>Click the add job button</li>
<li>Fill out the form</li>
<li>Submit the form</li>
</ol>


<p>Now, try this on your own, step by step, before looking at the solution&hellip;</p>

<pre><code class="javascript">test.only('New Job', async (t) =&gt; {
  // click add job button
  await t
    .click(addJobButton)
    .expect(title.innerText).eql('Add Job');
  // fill out form
  await t
    .typeText('input[name="title"]', 'Python Developer')
    .typeText('textarea[name="description"]', 'Write some Python')
    .typeText('input[name="company"]', 'Real Python')
    .typeText('input[name="email"]', 'michael@realpython.com')
    .click(submitButton)
  // check title, table rows, and new job exists
  await t
    .expect(title.innerText).eql('All Jobs')
    .expect(tableRows.count).eql(4)
    .expect(Selector('tbody &gt; tr').withText('Python Developer').exists).ok();
});
</code></pre>

<p>Make sure to add the selector to the top:</p>

<pre><code class="javascript">const submitButton = Selector('button[type="submit"]');
</code></pre>

<p>Test it out. Then remove the <code>only()</code> and test again:</p>

<pre><code class="sh">Node Jobs
âœ“ All Jobs
âœ“ New Job


2 passed (4s)
</code></pre>

<p>What are we missing in this test?</p>

<ol>
<li>What happens if the cancel button is pressed?</li>
<li>What if the end user does not enter data for all the fields?</li>
<li>What if text is entered in the email field but it is not a valid email?</li>
</ol>


<p>Try testing for these on your own.</p>

<h3>Update Job</h3>

<p>Again, start by adding the boilerplate:</p>

<pre><code class="javascript">test('Update Job', async (t) =&gt; {

});
</code></pre>

<p>Then write out the steps the end user has to take before writing any code:</p>

<ol>
<li>Click the update button</li>
<li>Fill out the form</li>
<li>Submit the form</li>
</ol>


<pre><code class="javascript">test('Update Job', async (t) =&gt; {
  // click update button
  await t
    .click(firstJob.find('a.btn.btn-warning'))
    .expect(title.innerText).eql('Update Job');
  // fill out form
  await t
    .typeText('input[name="title"]', 'testing an update', {replace: true})
    .typeText('textarea[name="description"]', 'test', {replace: true})
    .typeText('input[name="company"]', 'test', {replace: true})
    .typeText('input[name="email"]', 't@t.com', {replace: true})
    .click(submitButton)
  // check title, table rows, and updated job exists
  await t
    .expect(title.innerText).eql('All Jobs')
    .expect(tableRows.count).eql(4) // why 4?
    .expect(firstJob.exists).notOk()
    .expect(Selector('tbody &gt; tr').withText('testing an update').exists).ok();
});
</code></pre>

<p>Test:</p>

<pre><code class="sh">Node Jobs
âœ“ All Jobs
âœ“ New Job
âœ“ Update Job


3 passed (8s)
</code></pre>

<p>What else should you test for? Write the test cases on your own.</p>

<p>Also, did you notice the code smell? There&rsquo;s a lot of code duplication happening between those last two test cases. How could this be better handled?</p>

<p>Finally, did you notice that there are still four jobs in the table? Why? Could there be issues with testing the previous two tests together rather than in isolation? Probably not in this case, but if there are, you could always wrap the update in a new <code>fixture()</code>, since this restores the page to its initial state.</p>

<h3>Delete Job</h3>

<p>Run the app again with <code>npm start</code> to review, from the end user&rsquo;s perspective, what happens when you try to delete a job.</p>

<pre><code class="javascript">test('Delete Job', async (t) =&gt; {
  // click delete button
  await t
    .setNativeDialogHandler(() =&gt; true)
    .click(clayDryerJob.find('a.btn.btn-danger'))
  // check title, table rows, and updated job exists
  await t
    .expect(title.innerText).eql('All Jobs')
    .expect(tableRows.count).eql(3) // why 3?
    .expect(clayDryerJob.exists).notOk();
});
</code></pre>

<p>Did you notice the <code>setNativeDialogHandler()</code> function? <a href="https://devexpress.github.io/testcafe/documentation/test-api/handling-native-dialogs.html#dialog-handler">This</a> tells TestCafe how to handle the alert.</p>

<p>What if we click &ldquo;cancel&rdquo; instead of &ldquo;ok&rdquo;?</p>

<pre><code class="javascript">test('Delete Job', async (t) =&gt; {
  // click delete button
  await t
    .setNativeDialogHandler(() =&gt; true) // =&gt; press ok
    .click(clayDryerJob.find('a.btn.btn-danger'))
  // check title, table rows, and updated job exists
  await t
    .expect(title.innerText).eql('All Jobs')
    .expect(tableRows.count).eql(3) // why 3?
    .expect(clayDryerJob.exists).notOk();
    // click delete button
  await t
    .setNativeDialogHandler(() =&gt; false) // =&gt; press cancel
    .click(tableRows.find('a.btn.btn-danger'))
  // check title, table rows, and updated job exists
  await t
    .expect(title.innerText).eql('All Jobs')
    .expect(tableRows.count).eql(3) // why 3?
});
</code></pre>

<p>Run the tests:</p>

<pre><code class="sh">Node Jobs
âœ“ All Jobs
âœ“ New Job
âœ“ Update Job
âœ“ Delete Job


4 passed (9s)
</code></pre>

<p>Again, handle any edge cases on you own and clean up the code smell.</p>

<h2>Browser Support</h2>

<p>Aside for Chrome, TestCafe <a href="https://devexpress.github.io/testcafe/documentation/using-testcafe/common-concepts/browser-support.html#officially-supported-browsers">supports</a> a number of browsers out-of-the-box. Further, if you don&rsquo;t need to test browser-dependent functionality, then you can use a headless browser.</p>

<p>Start by installing the <a href="https://github.com/ryx/testcafe-browser-provider-nightmare">plugin</a>, which is powered by <a href="https://github.com/segmentio/nightmare">Nightmare</a>:</p>

<pre><code class="sh">$ npm install testcafe-browser-provider-nightmare@0.0.4 --save-dev
</code></pre>

<p>Update the <code>test</code> command in <em>package.json</em>:</p>

<pre><code class="json">"test": "node_modules/testcafe/bin/testcafe.js nightmare tests/jobs.js --app 'npm start'"
</code></pre>

<p>Run the tests, and you should see:</p>

<pre><code class="sh">Running tests in:
- Electron 1.6.2 / Mac OS X 10.11.6

Node Jobs
âœ“ All Jobs
âœ“ New Job
âœ“ Update Job
âœ“ Delete Job


4 passed (9s)
</code></pre>

<p>There&rsquo;s also a <a href="https://github.com/DevExpress/testcafe-browser-provider-saucelabs">plugin</a> for cross browser support powered by <a href="https://saucelabs.com/">SauceLabs</a>.</p>

<h2>Continuous Integration</h2>

<p>Finally, let&rsquo;s incorporate TestCafe into our Continuous Integration (CI) process with <a href="https://travis-ci.org/">Travis CI</a>.</p>

<blockquote><p><strong>NOTE:</strong> New to Travis? Review the <a href="https://docs.travis-ci.com/user/for-beginners">Travis CI for Complete Beginners</a> guide along with <a href="http://devexpress.github.io/testcafe/documentation/recipes/running-tests-in-firefox-and-chrome-using-travis-ci.html">Running Tests in Firefox and Chrome Using Travis CI</a>.</p></blockquote>

<p>After you enable Travis CI for the repository you are working with, add a <em>.travis.yml</em> file to the project root:</p>

<pre><code>language: node_js
node_js: "7"

dist: trusty
sudo: required

addons:
  apt:
    sources:
     - google-chrome
    packages:
     - google-chrome-stable

before_script:
  - "export DISPLAY=:99.0"
  - "sh -e /etc/init.d/xvfb start"
  - sleep 3
</code></pre>

<p>Here, we added the Node version along with some basic Chrome settings. Also, we have to use <a href="https://docs.travis-ci.com/user/gui-and-headless-browsers/#Using-xvfb-to-Run-Tests-That-Require-a-GUI">xvfb</a> to fake a GUI so that Chrome thinks it&rsquo;s running in a graphical environment.</p>

<hr><br>


<p>That&rsquo;s it. Grab the final code from the <a href="https://github.com/mjhea0/testcafe-example">testcafe-example</a> repo. Comment below if you have questions.</p>
]]></content>
  </entry>
  
</feed>
